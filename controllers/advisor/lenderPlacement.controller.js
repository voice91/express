/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import httpStatus from 'http-status';
import {
  s3Service,
  lenderPlacementService,
  emailService,
  emailTemplateService,
  activityLogService,
  lenderContactService,
  dealService,
  userService,
  invitationService,
  taskService,
  tokenService,
} from 'services';
import { catchAsync } from 'utils/catchAsync';
import FileFieldValidationEnum from 'models/fileFieldValidation.model';
import mongoose from 'mongoose';
import TempS3 from 'models/tempS3.model';
import {
  asyncForEach,
  checkTermAdded,
  encodeUrl,
  getEmailSubjectForDeal,
  getStateFullName,
  getTextFromTemplate,
  manageDealStageTimeline,
  manageLenderPlacementStageTimeline,
} from 'utils/common';
import _, {find, includes, isEmpty, isUndefined, round, sum} from 'lodash';
import { pick } from '../../utils/pick';
import ApiError from '../../utils/ApiError';
import { Deal, EmailTemplate, LenderPlacement, User } from '../../models';
import { borrowerSendDealEmailContent, followUpEmailContent, sendDealTemplate1Text } from '../../utils/emailContent';
import enumModel, {
  EnumOfActivityType,
  EnumOfEmailStatus,
  EnumStageOfDeal,
  EnumStageOfLenderPlacement,
} from '../../models/enum.model';
import config from '../../config/config';
import { stageOfLenderPlacementWithNumber } from '../../utils/enumStageOfLenderPlacement';
import { detailsInDeal } from '../../utils/detailsInDeal';
import { stageOfDealWithNumber } from '../../utils/enumStageForDeal';
import {
  removeLenderPlacementAssociatedThings,
} from "../../services/lenderPlacement.service";
import { logger } from "../../config/logger";
import {decrypt} from "../../utils/encrypt-decrypt-text";

// eslint-disable-next-line import/no-extraneous-dependencies
const he = require('he');

const moveFileAndUpdateTempS3 = async ({ url, newFilePath }) => {
  const newUrl = await s3Service.moveFile({ key: url, newFilePath });
  await TempS3.findOneAndUpdate({ url }, { url: newUrl });
  return newUrl;
};
// this is used to move file to new specified path as shown in basePath, used in create and update controller.
const moveFiles = async ({ body, user, moveFileObj }) => {
  await asyncForEach(Object.keys(moveFileObj), async (key) => {
    const fieldValidation = FileFieldValidationEnum[`${key}OfLenderPlacement`];
    const basePath = `users/${user._id}/lenderPlacement/${body._id}/${key}/${mongoose.Types.ObjectId()}/`;
    if (Array.isArray(moveFileObj[key])) {
      const newUrlsArray = [];
      moveFileObj[key].map(async (ele) => {
        const filePath = `${mongoose.Types.ObjectId()}_${ele.split('/').pop()}`;
        newUrlsArray.push(await moveFileAndUpdateTempS3({ url: ele, newFilePath: basePath + filePath }));
      });
      Object.assign(body, { ...body, [key]: await Promise.all(newUrlsArray) });
    } else {
      const filePath = `${mongoose.Types.ObjectId()}_${moveFileObj[key].split('/').pop()}`;
      Object.assign(body, {
        ...body,
        [key]: await moveFileAndUpdateTempS3({
          url: moveFileObj[key],
          newFilePath: basePath + filePath,
        }),
      });
      if (fieldValidation.generateThumbnails) {
        Object.assign(body, {
          ...body,
          [`thumbOf${key}`]: await s3Service.createThumbnails({
            url: moveFileObj[key],
            resolutions: fieldValidation.thumbnailResolutions,
          }),
        });
      }
    }
  });
};

/**
 * we send the necessary data in this API so FE can show the template to user
 * @type {(function(*, *, *): void)|*}
 */
export const getEmailDataV3 = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.query;
  const filter = {
    _id: {$in:lenderPlacementId},
  };
  const options = {
    populate: [
      { path: 'lenderContact' },
      { path: 'deal',
        populate: {
          path: 'dealSummary',
        },
      },
    ],
  };
  const lenderPlacements = await lenderPlacementService.getLenderPlacementList(filter, options);
  if(lenderPlacementId.length !== lenderPlacements.length) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Some lender placement is not available');
  }
  const hasSameDealId = lenderPlacements.every(
      (placement) => placement.deal.id === lenderPlacements[0].deal.id && placement.lenderContact
  );

  if(!hasSameDealId) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Contact should be selected to send the deal & deal should be same for all the placements');
  }
  const dealSummaryDocs = [];
  if (lenderPlacements[0].deal.dealSummary.documents && lenderPlacements[0].deal.dealSummary.documents.length) {
    dealSummaryDocs.push(...lenderPlacements[0].deal.dealSummary.documents);
  }
  // we need UW Excel sheet too in the email attachment, and we are storing that in data sheet so adding that in the dealSummaryDocs
  if (lenderPlacements[0].deal.dealSummary.dataSheet && lenderPlacements[0].deal.dealSummary.dataSheet.url) {
    dealSummaryDocs.push(lenderPlacements[0].deal.dealSummary.dataSheet);
  }
  const emailAttachments = dealSummaryDocs.map((item) => {
    return {
      fileName: item.fileName,
      path: item.url,
      fileType: item.url.split('.').pop(),
    };
  });

  const subject = getEmailSubjectForDeal(lenderPlacements[0].deal.dealSummary._doc)
  const response = {
    subject,
    emailAttachments,
    deal: lenderPlacements[0].deal,
    sendTo: lenderPlacements.map((lenderPlacement)=> {
      return {
        name: lenderPlacement.lenderContact.firstName,
        email: lenderPlacement.lenderContact.email
      }}),
    advisorName: req.user.firstName,
    signature: req.user.signature
  }
  return res.status(httpStatus.OK).send({ results: response });
});

/**
 * we are sending email for send deal to lender with email template
 * @type {(function(*, *, *): void)|*}
 */
export const sendEmailV3 = catchAsync(async (req, res) => {
  const { sendToAdvisor, isFollowUp, ccList } = req.body;

  // const { emailPresentingPostmark } = req.user;
  //a function call that decodes HTML-encoded text. It's commonly used to decode HTML entities like &lt; (represents <), &gt; (represents >), &amp; (represents &), and so on.
  req.body.emailContent = req.body.emailContent && he.decode(req.body.emailContent);
  req.body.followUpContent = req.body.followUpContent && he.decode(req.body.followUpContent);

  _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  //function for format currency (round of the value and to show in the form of 'k' if the value is less than 1 million)
const formatCurrency = (amount) => {
    if (typeof amount === 'string') {
      const floatValue = getAmountInFloat(amount);
      if (isNaN(floatValue)) {

        return 0;
      }
      amount = floatValue;

    } else if (isUndefined(amount)) {
      return 0;
    }
    if (amount >= 1000000) {
      const lastDigit = round(amount / 1000000, 2)
          .toString()
          .slice(-1);
      if (lastDigit === '5') {
        return `$${round(amount / 1000000, 2)}m`;
      } else {
        return `$${round(amount / 1000000, 1)}m`;
      }
    } else {
      return `$${round(amount / 1000, 0)}k`;
    }
  };

// To convert the value into string
const getAmountFromString = (value) => {
    if (value) {
      return value.toString()?.replace(/[$,]/g, '');
    }
    return value;
  };

// To convert the value into float
const getAmountInFloat = (value, removeDollarAndCommas = true) => {
    if (value) {
      if (removeDollarAndCommas) {
        return parseFloat(getAmountFromString(value));
      }
      return parseFloat(value?.toString());
    }
    return value;
  };

// To remove the sentence for unitCount, Occupancy and SF when we don't have its value
 const removeStringFromTemplate = (sentence = '') => {
    const updatedSentence = sentence
        .replace(/\[unitCount\]-unit,/, '')
        .replace(/\[Occupancy\] occupied/, '')
        .replace(/\[Square Footage\] SF,/, '');
    return updatedSentence;
  };

  // we need to populate the deal summary as for the email's subject we need heading field of the deal summary
  const dealDetail = await dealService.getOne({_id: req.body.deal},{populate: {path: 'dealSummary'}} )
  const dealId = dealDetail._id;
  const dealSummaryUsesData = dealDetail?.dealSummary?.sourcesAndUses?.uses || [];
  const totalUses = sum(dealSummaryUsesData?.map((use) => getAmountInFloat(use?.value)));
  const removeTotalUses = dealSummaryUsesData?.filter((item) => item?.key !== 'Total Uses');
  const usesKeyValue = removeTotalUses
      ?.map((value) => {
        return `${formatCurrency(value.value)} of ${value.key}`;
      })
      .join(', ');
  const firstUsesValue = formatCurrency(dealSummaryUsesData ? _.get(dealSummaryUsesData[0], 'value', '') : '');
  const ltcValue = getAmountInFloat(dealDetail?.loanAmount) / totalUses || 0;
  const inPlaceDYVal = find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'In-Place DY')?.value;
  const inStabilizedDYVal = find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'Stabilized DY')?.value;
  const existingLoanBalance = find(dealSummaryUsesData, (data) =>
      includes(
          [
            'Loan Balance',
            'Current Loan Balance',
            'Existing Loan Balance',
            'Current Debt',
            'Current Debt Balance',
            'Debt Balance',
            'Payoff Loan Balance',
            'Payoff Current Loan Balance',
            'Payoff Existing Loan Balance',
            'Payoff Current Debt Balance',
            'Payoff Debt Balance',
          ],
          data?.key
      )
  )?.value;
  if (sendToAdvisor) {
    let firstName = 'lenderName'
    // if we send to multiple placement than send generic lender name else selected lender name
    if(req.body.lenderPlacementIds.length === 1){
      const options = {
        populate: [
          {
            path: 'lenderContact'
          },
        ]
      }
      const lenderPlacement = await lenderPlacementService.getOne({ _id: req.body.lenderPlacementIds[0] }, options);
      firstName = lenderPlacement.lenderContact.firstName
    }
    // Todo: create common function for creating template for both send test email and send email
    const isAdvisor = _.template(req.body.emailContent)({
      lenderFirstName: _.startCase(firstName),
      advisorName:_.startCase(req.user.firstName),
      sponsorName: '[[Sponsor Name]]',
      amount: formatCurrency(dealDetail?.loanAmount) || 'NA',
      loanPurpose: dealDetail.loanPurpose || 'NA',
      dealName: dealDetail.dealName || 'NA',
      unitCount: dealDetail.unitCount || '[unitCount]',
      propertyType: dealDetail.assetType || 'NA',
      toBeBuilt: 'NA',
      address: dealDetail.address || 'NA',
      city: dealDetail.city || 'NA',
      state: getStateFullName(dealDetail.state) || 'NA',
      purchasePrice: formatCurrency(find(dealSummaryUsesData, (data) => data.key === 'Purchase Price')?.value) || 'NA',
      inPlaceNOI: formatCurrency(find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'In-Place NOI')?.value) || 'NA',
      stabilizedNOI: formatCurrency(find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'Stabilized NOI')?.value) || 'NA',
      squareFootage: dealDetail?.squareFootage || '[Square Footage]',
      occupancy: dealDetail?.occupancy || '[Occupancy]',
      totalUsesValue: !isEmpty(dealSummaryUsesData) ? formatCurrency(totalUses) : 'NA',
      usesKeyValue: usesKeyValue || 'NA',
      LTC: round(ltcValue / 100, 1) || 'NA',
      firstUsesValue: firstUsesValue || 'NA',
      existingLoanBalance: existingLoanBalance || 'NA',
      inPlaceDY: inPlaceDYVal ? `${getAmountInFloat(inPlaceDYVal)}%` : 'NA',
      stabilizedDY: inStabilizedDYVal ? `${getAmountInFloat(inStabilizedDYVal)}%` : 'NA',
      sponsorBioName: '[[Sponsor bio from Sponsor bio page]]',
      loanTypeValue: dealDetail?.loanType || 'NA',
      dealSummaryLink: `<a href='#'>Deal Summary</a>`,
      passLink:`<a href='#'>Pass</a>`,
    });
    const emailAttachments = req.body.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });

    await emailService.sendEmailUsingGmail({
      to: req.user.email,
      from: req.user.sendEmailFrom,
      pass: decrypt(req.user.appPassword, config.encryptionPassword),
      subject: `TEST - ${getEmailSubjectForDeal(dealDetail.dealSummary)}`, //calling commmon function for setting subject
      // ...(emailPresentingPostmark && { from: req.user.email }),
      text: removeStringFromTemplate(isAdvisor),
      attachments: emailAttachments,
      isHtml: true,
      // headers - if you want the functionality like advisor can also reply its own email then we can pass the headers
    });
    logger.info(`Test email successfully sent to ${req.user.email} from ${req.user.sendEmailFrom}`);
    return res.status(httpStatus.OK).send({ results: 'Test-mail sent..' });
  }
  const getText = (passLink, dealSummaryLink, firstName) => {
    const data = _.template(req.body.emailContent)({
      lenderFirstName: _.startCase(firstName),
      advisorName:_.startCase(req.user.firstName),
      sponsorName: '[[Sponsor Name]]',
      amount: formatCurrency(dealDetail?.loanAmount) || 'NA',
      loanPurpose: dealDetail?.loanPurpose || 'NA',
      dealName: dealDetail?.dealName || 'NA',
      unitCount: dealDetail?.unitCount || '[unitCount]',
      propertyType: dealDetail?.assetType || 'NA',
      toBeBuilt: 'NA',
      address: dealDetail?.address || 'NA',
      city: dealDetail?.city || 'NA',
      state: getStateFullName(dealDetail.state) || 'NA',
      purchasePrice: formatCurrency(find(dealSummaryUsesData, (data) => data.key === 'Purchase Price')?.value) || 'NA',
      inPlaceNOI: formatCurrency(find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'In-Place NOI')?.value) || 'NA',
      stabilizedNOI: formatCurrency(find(dealDetail?.dealSummary?.dealMetrics, (data) => data.key === 'Stabilized NOI')?.value) || 'NA',
      squareFootage: dealDetail?.squareFootage || '[Square Footage]',
      occupancy: dealDetail?.occupancy || '[Occupancy]',
      totalUsesValue: !isEmpty(dealSummaryUsesData) ? formatCurrency(totalUses) : 'NA',
      usesKeyValue: usesKeyValue || 'NA',
      LTC: round(ltcValue / 100, 1) || 'NA',
      firstUsesValue: firstUsesValue || 'NA',
      existingLoanBalance: existingLoanBalance || 'NA',
      inPlaceDY: inPlaceDYVal ? `${getAmountInFloat(inPlaceDYVal)}%` : 'NA',
      stabilizedDY: inStabilizedDYVal ? `${getAmountInFloat(inStabilizedDYVal)}%` : 'NA',
      sponsorBioName: '[[Sponsor bio from Sponsor bio page]]',
      loanTypeValue: dealDetail?.loanType || 'NA',
      dealSummaryLink: `<a href=${dealSummaryLink}>Deal Summary</a>`,
      passLink:`<a href=${passLink}>Pass</a>`,
    });
    return removeStringFromTemplate(data)
  };
  // for adding lender's userid in the deal when we send deal to them
  const lenderUserIdsToAddInDeal= []
  // we send email to all selected placement & if we have one than also we are taking in the array
  await Promise.all(
      req.body.lenderPlacementIds.map(async (lenderPlacementId) => {
        const options = {
          populate: [
          { path: 'lenderContact' },
          ]
      }
        const lenderPlacement = await lenderPlacementService.getOne({ _id: lenderPlacementId }, options);
        const frontEndUrl = config.front.url || 'http://54.196.81.18';

        let user = await userService.getOne({ email: lenderPlacement.lenderContact.email, role: enumModel.EnumRoleOfUser.LENDER });
        if (!user) {
          const isLenderContact = await lenderContactService.getOne({ email: lenderPlacement.lenderContact.email }, { populate: 'lenderInstitute' });
          // create user if user has not register
          const userBody = {
            firstName: isLenderContact.firstName,
            companyName: isLenderContact.lenderInstitute.lenderNameVisible,
            lastName: isLenderContact.lastName,
            role: enumModel.EnumRoleOfUser.LENDER,
            enforcePassword: true,
            email: lenderPlacement.lenderContact.email,
            emailVerified: true,
            password: Math.random().toString(36).slice(-10)
          }
          user = await userService.createUser(userBody);
        }
        lenderUserIdsToAddInDeal.push(user._id)
        const tokens = await tokenService.generateAuthTokens(user);
        const dealSummaryLink =`${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&token=${tokens.access.token}`
        const passLink = `${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&pass=true&token=${tokens.access.token}`;
        const headers = [
          {
            Value: `${lenderPlacementId}`,
          },
        ];

        // It generates email text with placeholders replaced by actual parameter values for follow-up mail
        const getFollowUpContent = () => {
          return _.template(req.body.followUpContent)({
            lenderFirstName: _.startCase(lenderPlacement.lenderContact.firstName) || 'Lender',
            dealSummaryLink: `<a href=${dealSummaryLink}>Deal Summary</a>`,
            advisorName: _.startCase(req.user.firstName) || 'Advisor',
            passLink: `<a href=${passLink}>Pass</a>`,
          });
        };

        // we have to send followup email in thread so need to add this header
        if (isFollowUp) {
          headers.push({ Name: 'In-Reply-To', Value: lenderPlacement.postmarkMessageId[0] });
        }
        const response = await emailService.sendEmailUsingGmail({
          to: lenderPlacement.lenderContact.email,
          cc: ccList,
          subject: isFollowUp ? `RE: ${getEmailSubjectForDeal(dealDetail.dealSummary)}` : `${getEmailSubjectForDeal(dealDetail.dealSummary)}`, //calling commmon function for setting subject
          // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
          from: req.user.sendEmailFrom,
          pass: decrypt(req.user.appPassword, config.encryptionPassword),
          // for followup, we use this template
          text: isFollowUp ? getFollowUpContent() :
          getText(passLink, dealSummaryLink, lenderPlacement.lenderContact.firstName),
          attachments: req.body.emailAttachments && req.body.emailAttachments.map((item) => {
            return {
              fileName: item.fileName,
              path: item.url ? item.url : item.path,
              fileType: item.fileType,
            };
          }),
          isHtml: true,
          headers,
          // when we reply than it should go to sender also & sender is sendEmailFrom
          replyTo: req.user.sendEmailFrom,
        });
        if(isFollowUp){
          logger.info(`Follow up mail sent successfully to ${lenderPlacement.lenderContact.email} from ${req.user.sendEmailFrom}`);
        }
        else{
          logger.info(`Email for deal sent successfully to ${lenderPlacement.lenderContact.email} from ${req.user.sendEmailFrom}`);
        }
        //Adding postmark message id in placement while updating lender placement when deal is sent
        const postmarkMessageId = response.MessageID || response.messageId;
        if (lenderPlacement.isEmailSent === EnumOfEmailStatus.SEND_DEAL) {
          const stage = EnumStageOfLenderPlacement.SENT;
          await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
            followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
            isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
            isEmailSentFirstTime: true,
            $addToSet: {
              postmarkMessageId,
              sendEmailPostmarkMessageId: postmarkMessageId
            },
            stage,
            stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
            nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
            timeLine: manageLenderPlacementStageTimeline(lenderPlacement.stage, stage, lenderPlacement.timeLine),
          });
        } else {
          //Adding postmark message id in placement while updating lender placement when we follow up for deal
          await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
            followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
            isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
            isEmailSentFirstTime: false,
            $addToSet: {
              postmarkMessageId,
              sendEmailPostmarkMessageId: postmarkMessageId
            },
          });
        }
      })
  );

  const stage = EnumStageOfDeal.OUT_IN_MARKET;
  const deal = await Deal.findByIdAndUpdate(dealId, {
    stage,
    $addToSet: { 'involvedUsers.lenders': { $each: lenderUserIdsToAddInDeal } },
    orderOfStage: stageOfDealWithNumber(stage),
    timeLine: manageDealStageTimeline(
        dealDetail.stage,
        stage,
        dealDetail.timeLine
    ),
    details: await detailsInDeal(stage, dealId),
  }, {new: true});
  const createActivityLogBody = {
    createdBy: req.user._id,
    updatedBy: req.user._id,
    update: `${deal.dealName} was sent out to lenders`,
    deal: dealId,
    type: EnumOfActivityType.ACTIVITY,
    user: config.activitySystemUser || 'system',
  };
  await activityLogService.createActivityLog(createActivityLogBody);
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const get = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    populate: [
      { path: 'lendingInstitution' },
      { path: 'notes', match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE } },
    ],
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});
const getLenderPlacementFilterQuery = (query) => {
  const filter = pick(query, ['deal', 'stage', 'isFavourite', 'isArchived']);
  if (query.search) {
    filter.$or = [{ firstName: new RegExp(query.search, 'i') }, { lastName: new RegExp(query.search, 'i') }];
  }
  return filter;
};
export const list = catchAsync(async (req, res) => {
  const { query, user } = req;
  const queryParams = getLenderPlacementFilterQuery(query);

  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    isFavourite: 'desc',
    [sortingObj.sort]: sortingObj.order,
  };

  const filter = {
    ...queryParams,
    stage: query.stage ? query.stage : { $ne: EnumStageOfLenderPlacement.ARCHIVE },
  };
  const options = {
    ...pick(query, ['sort', 'limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'task',
        match: {
          deal: query.deal,
          isCompleted: false
        },
      },
      {
        path: 'outstandingTaskCount',
        count: true,
        match: {
          deal: query.deal,
          isCompleted: false,
        },
      },
      {
        path: 'notes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE },
      },
      {
        path: 'internalNotes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.INTERNAL_NOTE },
      },
    ],
    //by default messages field is set as select false in the model.
    //we required messages field along with the other field so added + with the messages.
    select: '+messages'
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
    options.collation = { locale: 'en', caseLevel: false }; // Case-insensitive sorting
  }
  let lenderPlacement = await lenderPlacementService.getLenderPlacementList(filter, options);
  // filter out if we only need outstanding tasks placement
  // if we want to find according to it than DB query will be increase & it takes more time bcs we are counting outstandingTaskCount by virtual & matching
  if (query.outstandingTask) {
    lenderPlacement = lenderPlacement.filter((placement) => placement.outstandingTaskCount > 0);
  }
  //checking for the new messages is available or not .
  //if current logged-in user's id is not available in messageReadBy array , then it is considered as this message is new, not read by user previously & hasNewMessagesAvailable marked as true.
  //based on the hasNewMessagesAvailable , set the blue dot mark on the placement in FE.
  lenderPlacement = lenderPlacement.map((placement)=> {
    const hasNewMessage = placement.messages.some(message => !message.messageReadBy.includes(user._id))
    if (hasNewMessage){
      placement._doc.hasNewMessagesAvailable = true
    } else {
      placement._doc.hasNewMessagesAvailable = false
    }
    return placement
  })
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const paginate = catchAsync(async (req, res) => {
  const { query } = req;
  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    [sortingObj.sort]: sortingObj.order,
  };
  const filter = { ...pick(query, ['deal']) };
  const options = {
    ...pick(query, ['limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'notes',
      },
    ],
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
  }
  const lenderPlacement = await lenderPlacementService.getLenderPlacementListWithPagination(filter, options);
  lenderPlacement.results = lenderPlacement.results.map((lenderPlacementObject) => ({
    createdAt: lenderPlacementObject.createdAt,
    ...lenderPlacementObject.toJSON(),
  }));
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const create = catchAsync(async (req, res) => {
  const { body } = req;
  body.createdBy = req.user._id;
  body.updatedBy = req.user._id;
  const { user } = req;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet }),
  };
  if (body.stage) {
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
  }

  body._id = mongoose.Types.ObjectId();
  await moveFiles({ body, user, moveFileObj });
  const options = {};
  // Before it wasn't allowing other institute to add as well even if one is already added, so using promise.all so that it'll throw error for one but will allow others to get added in deal
  await Promise.all(
    body.lendingDetails.map(async (lendingInstitute) => {
      const placement = {
        ...lendingInstitute,
        createdBy: body.createdBy,
        updatedBy: body.updatedBy,
      };
      const lenderPlacementResult = await lenderPlacementService.createLenderPlacement(placement, options);

      if (lenderPlacementResult) {
        const uploadedFileUrls = [];
        uploadedFileUrls.push(lenderPlacementResult.termSheet);
        await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
      }
    })
  );
  return res.status(httpStatus.CREATED).send({ results: 'Lender added to the deal' });
});

export const update = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user._id;
  const { lenderPlacementId } = req.params;
  const { user } = req;
  const termsheet = body.termSheet;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet.url }),
  };
  body._id = lenderPlacementId;
  await moveFiles({ body, user, moveFileObj });
  const filter = {
    _id: lenderPlacementId,
  };
  if (body.termSheet) {
    const { fileName } = termsheet;
    body.termSheet = encodeUrl(body.termSheet);
    body.termSheet = { url: body.termSheet, fileName };
  }
  if (body.terms) {
    const futureFunding = body.terms.futureFunding ? body.terms.futureFunding : 0;
    body.terms.totalLoanAmount = body.terms.initialFunding + futureFunding;
  }

  const options = {
    new: true,
    populate: [
      { path: 'lendingInstitution' },
      { path: 'lenderContact' },
      // TODO : check & add condition here like in the getlist API & also check for outstanding task bcs it will be 0 when we change status to new & after changing status FE is calling getList API so they are getting updated data
      {
        path: 'internalNotes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.INTERNAL_NOTE },
      },
      { path: 'notes' },
      { path: 'lenderAllContacts' },
      { path: 'deal' },
    ],
  };
  const optionForGetPlacement = {
    populate: [
      {
        path: 'lenderContact'
      }
    ]
  }
  const beforeLenderPlacementResult = await lenderPlacementService.getLenderPlacementById(lenderPlacementId, optionForGetPlacement);

  // check & throw error if term is not added
  // bcs we have requirement that if term is added than only we can add term-sheet
  if (body.termSheet) {
    checkTermAdded(beforeLenderPlacementResult);
  }

  const oldStage = beforeLenderPlacementResult.stage;

  if (body.stage) {
    // we change the isEmailSent to same as what we have when we add lender bcs if we don't change than it will not chane stage of deal & timeline when we send the deal after changing stage
    if (body.stage === enumModel.EnumStageOfDeal.NEW) {
      body.isEmailSent = enumModel.EnumOfEmailStatus.SEND_DEAL;
      // When we change the status from sent to new then all the messages , contact, task, postmarkMessageId and sendEmailPostmarkMessageId should get removed
      body.isEmailSentFirstTime = false
      body.messages = [];
      body.$unset = { lenderContact: '', terms: '', termSheet: '', followOnDate: '' };
      body.postmarkMessageId = [];
      body.sendEmailPostmarkMessageId = [];
      await removeLenderPlacementAssociatedThings(beforeLenderPlacementResult)
    }
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
    body.nextStep = body.nextStep ? body.nextStep : enumModel.EnumNextStepOfLenderPlacement[body.stage];
    body.timeLine = manageLenderPlacementStageTimeline(oldStage, body.stage, beforeLenderPlacementResult.timeLine);
  }
  if (oldStage !== EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Only Archive possible when status changed from Closed to Archive..');
  }
  if (oldStage === EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage: EnumStageOfLenderPlacement.ARCHIVE,
    });
  }
  const lenderPlacementResult = await lenderPlacementService.updateLenderPlacement(filter, body, options);
  const dealId = lenderPlacementResult.deal;
  if (lenderPlacementResult.stage === enumModel.EnumStageOfLenderPlacement.CLOSING) {
    const stage = enumModel.EnumStageOfDeal.CLOSING;
    await Deal.findByIdAndUpdate(dealId, {
      stage,
      orderOfStage: stageOfDealWithNumber(stage),
      timeLine: manageDealStageTimeline(lenderPlacementResult.deal.stage, stage, lenderPlacementResult.deal.timeLine),
      details: await detailsInDeal(stage, dealId),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${lenderPlacementResult.deal.dealName} moved into closing with ${lenderPlacementResult.lendingInstitution.lenderNameVisible}`,
      deal: dealId,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  }
  // tempS3
  if (lenderPlacementResult.termSheet) {
    const uploadedFileUrls = [];
    uploadedFileUrls.push(lenderPlacementResult.termSheet.url);
    await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
  }
  // if termSheet added for first time than only we add activity logs and update lenderPlacement stage to termSheet Received
  if (!beforeLenderPlacementResult.termSheet && body.termSheet) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} posted a term sheet on ${lenderPlacementResult.deal.dealName}`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_SHEET_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }

  // if terms added for first time than only we add activity logs and update lenderPlacement stage to terms Received
  if (!beforeLenderPlacementResult.terms && body.terms) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} sent over terms`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }
  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const updateMany = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user;
  const { lenderPlacementIds } = req.body;
  const updateBody = req.body.update;
  const filter = {
    _id: { $in: lenderPlacementIds },
  };
  const options = { new: true };
  const lenderPlacementResult = await lenderPlacementService.updateManyLenderPlacement(filter, updateBody, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const remove = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeByDealAndLendingInstitution = catchAsync(async (req, res) => {
  const { deal, lendingInstitution } = req.query;
  const filter = {
    deal,
    lendingInstitution,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const sendDeal = catchAsync(async (req, res) => {
  const { lenderInstitute, deal, lenderPlacement } = req.body;
  const advisorName = req.user.name;
  const advisorEmail = req.user.email;
  const filterToFindContact = {
    lenderInstitute,
  };
  const filterToFindPlacement = {
    // lendingInstitution: lenderInstitute,
    _id: lenderPlacement,
  };
  const filterToFindDeal = {
    deal,
  };
  const lenderContact = await lenderPlacementService.sendDeal(filterToFindContact, filterToFindPlacement, filterToFindDeal);

  let lenderName;
  if (lenderContact.lenderPlacement.lendingInstitution) {
    lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
  }

  let totalLoanAmount = 0;
  const { docIds } = lenderContact;
  const createTemplates = [];

  if (!lenderContact.lenderPlacement.terms) {
    totalLoanAmount = 0;
  } else {
    totalLoanAmount = lenderContact.lenderPlacement.terms.totalLoanAmount;
    totalLoanAmount /= 1000000;
    totalLoanAmount = totalLoanAmount.toFixed(2);
  }

  if (lenderPlacement) {
    // now we have only on contact in placement so no need to add all contact
    const contact = [
      {
        sendTo: lenderContact.lenderPlacement.lenderContact.email,
        name: lenderContact.lenderPlacement.lenderContact.firstName,
      },
    ];
    const staticEmailTemplateData = sendDealTemplate1Text();
    const templateData = await EmailTemplate.find({
      lenderPlacement,
      isFirstTime: true,
    });

    let totalLoanAmountForSubject = lenderContact.lenderPlacement.deal.loanAmount.replace(/[$,]/g, '') * 1;
    // totalLoanAmount is converted into millions so if 1000000 then it should be 1
    totalLoanAmountForSubject /= 1000000;
    totalLoanAmountForSubject.toFixed(2);

    if (!templateData.length) {
      // TODO : we can remove the template things when we get time
      const defaultTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName,
        contact,
        // subject: '547 Valley Road - $1.5m Acquisition Financing',
        subject: `${lenderContact.lenderPlacement.deal.dealName}-$${totalLoanAmountForSubject}m Financing Request`,
        dealDocument: docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: true,
        isEmailSent: false,
        totalLoanAmount,
        templateName: `defaultTemplate - ${lenderName}`,
      });
      // create only one template for now
      // const blankTemplate = await EmailTemplate.create({
      //   from: advisorEmail,
      //   advisorName,
      //   contact,
      //   subject: '',
      //   dealDocument: docIds,
      //   emailContent: '',
      //   lenderPlacement,
      //   deal,
      //   emailAttachments: [],
      //   isFirstTime: true,
      //   isEmailSent: false,
      //   isBlankTemplate: true,
      //   templateName: `blankTemplate - ${lenderName}`,
      // });
      // createTemplates.push(defaultTemplate, blankTemplate);
      createTemplates.push(defaultTemplate);
    }
  }
  return res.status(httpStatus.OK).send({ createTemplates });
});

export const getEmailTemplatesByLanderPlacementId = catchAsync(async (req, res) => {
  const { lenderPlacement } = req.params;
  const filter = {
    lenderPlacement,
  };

  const emailTemplate = await emailTemplateService.getEmailTemplateList(filter);
  return res.status(httpStatus.OK).send({ results: emailTemplate });
});

export const getTemplateByTemplateId = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const options = {
    populate: [
      {
        path: 'deal',
        populate: {
          path: 'dealSummary',
        },
      },
    ],
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter, {}, options);
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id!');
  }
  // need to send attachment so getting all attachment of dealSummary
  const dealSummaryDocs = [];
  if (getEmailTemplate.deal.dealSummary.documents && getEmailTemplate.deal.dealSummary.documents.length) {
    dealSummaryDocs.push(...getEmailTemplate.deal.dealSummary.documents);
  }
  const emailAttachments = dealSummaryDocs.map((item) => {
    return {
      fileName: item.fileName,
      path: item.url,
      fileType: item.url.split('.').pop(),
    };
  });
  getEmailTemplate.emailAttachments = emailAttachments;
  return res.status(httpStatus.OK).send({ getEmailTemplate });
});

export const updateAndSaveInitialEmailContent = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter).lean();
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  if (req.body.templateName === getEmailTemplate.templateName) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'A template with the same name already exists..');
  }

  const body = {
    ...getEmailTemplate,
  };
  delete body._id;

  const emailContent = req.body.emailContent ? req.body.emailContent : body.emailContent;

  const updatedBody = {
    ...body,
    ...req.body,
    ...{ lenderPlacement: getEmailTemplate.lenderPlacement },
    ...{ isFirstTime: false },
    ...{
      /*
       * he (for “HTML entities”) is a robust HTML entity encoder/decoder written in JavaScript
       * */
      emailContent: he.decode(emailContent),
    },
  };

  if (updatedBody.emailAttachments) {
    const emailAttachments = updatedBody.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });
    delete updatedBody.emailAttachments;
    updatedBody.emailAttachments = emailAttachments;
  }
  if (updatedBody.sendTo) {
    const result = updatedBody.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (updatedBody.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = updatedBody.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }

          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);
          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      updatedBody.contact = data;
    } else {
      updatedBody.contact = result;
    }
    delete updatedBody.sendTo;
  }

  const templateData = await EmailTemplate.create(updatedBody);

  return res.status(httpStatus.OK).send({ templateData });
});

export const sendEmail = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;
  const { sendToAdvisor } = req.body;
  const filter = {
    _id: emailTemplateId,
  };
  const getUser = await User.findOne({ _id: req.user._id });
  const { emailPresentingPostmark } = getUser;
  const emailTemplate = await EmailTemplate.findOne(filter).lean().populate('deal');

  if (!emailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  let getEmailTemplate;
  if (req.body.getEmailTemplate) {
    getEmailTemplate = req.body.getEmailTemplate;
    const result = getEmailTemplate.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (emailTemplate.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = emailTemplate.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }
          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);

          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      getEmailTemplate.contact = data;
    } else {
      getEmailTemplate.contact = result;
    }
    delete getEmailTemplate.sendTo;
    if (getEmailTemplate.emailContent) {
      getEmailTemplate.emailContent = he.decode(getEmailTemplate.emailContent);
    }
  } else {
    getEmailTemplate = emailTemplate;
  }

  const placementId = getEmailTemplate.lenderPlacement;

  const dealId = emailTemplate.deal._id;

  const ccList = getEmailTemplate.ccList.map((item) => item);

  const bccList = getEmailTemplate.bccList.map((item) => item);

  const headers = [
    {
      Value: `${placementId}`,
    },
  ];

  const sendToIsEmpty = getEmailTemplate.contact.map((item) => item.sendTo);
  _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  if (sendToIsEmpty.length === 0) {
    return res.status(httpStatus.OK).send({ results: 'No email addresses to send to.' });
  }
  const dealDetail = emailTemplate.deal
  if (sendToAdvisor) {
    const isAdvisor = _.template(getEmailTemplate.emailContent)({
      // userFirstName: req.user.firstName,
      // totalLoanAmount: getEmailTemplate.totalLoanAmount,
      // advisorName: req.user.firstName,
      // advisorEmail: req.user.email,
      sponsorName: emailTemplate.advisorName || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[amount]',
      loanPurpose: dealDetail.loanPurpose || '[loan purpose]',
      dealName: dealDetail.dealName || '[deal name]',
      unitCount: dealDetail.unitCount || '[unitCount]',
      propertyType: dealDetail.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail.address || '[address]',
      city: dealDetail.city || '[city]',
      state: getStateFullName(dealDetail.state) || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx purchasePrice]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      passLink:"",
      dealSummaryLink: "",
    });
    const emailAttachments = getEmailTemplate.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });

    await emailService.sendEmail({
      to: req.user.email,
      subject: `TEST - ${getEmailTemplate.subject}`,
      ...(emailPresentingPostmark && { from: req.user.email }),
      text: isAdvisor,
      attachments: emailAttachments,
      isHtml: true,
      headers,
    });
    return res.status(httpStatus.OK).send({ results: 'Test-mail sent..' });
  }
  const getText = (passLink, dealSummaryLink) => {
    // const getText = (userFirstName, totalLoanAmount, advisorName, advisorEmail) => {
    const data = _.template(getEmailTemplate.emailContent)({
      // userFirstName,
      // totalLoanAmount,
      // advisorName,
      // advisorEmail,
      sponsorName: emailTemplate.advisorName || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail?.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[x.xx]',
      loanPurpose: dealDetail?.loanPurpose || '[loan purpose]',
      dealName: dealDetail?.dealName || '[deal name]',
      unitCount: dealDetail?.unitCount || '[unitCount]',
      propertyType: dealDetail?.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail?.address || '[address]',
      city: dealDetail?.city || '[city]',
      state: getStateFullName(dealDetail.state) || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      dealSummaryLink: `<a href=${dealSummaryLink}>Deal Summary</a>`,
      passLink:`<a href=${passLink}>Pass</a>`,
    });
    return data;
  };

  // todo : make function for this one, and make synchronize so we can handle error coming from that.
  await Promise.allSettled(
    getEmailTemplate.contact.map(async (item, index) => {
      const frontEndUrl = config.front.url || 'http://54.196.81.18';

      let user = await userService.getOne({ email: item.sendTo, role: enumModel.EnumRoleOfUser.LENDER });
      if (!user) {
        const isLenderContact = await lenderContactService.getOne({ email: item.sendTo }, { populate: 'lenderInstitute' });
        // create user if user has not register
        const userBody = {
          firstName: isLenderContact.firstName,
          companyName: isLenderContact.lenderInstitute.lenderNameVisible,
          lastName: isLenderContact.lastName,
          role: enumModel.EnumRoleOfUser.LENDER,
          enforcePassword: true,
          email: item.sendTo,
          emailVerified: true,
          password: Math.random().toString(36).slice(-10)
        }
        user = await userService.createUser(userBody);
      }
      const tokens = await tokenService.generateAuthTokens(user);
      const dealSummaryLink =`${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&token=${tokens.access.token}`
      const passLink = `${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&pass=true&token=${tokens.access.token}`;
      return emailService.sendEmail({
        to: item.sendTo,
        // bcs we want that email to cc & bcc will go to only once
        ...(index === 0 && {cc: ccList, bcc: bccList}),
        subject: getEmailTemplate.subject,
        // ...(emailPresentingPostmark && { from: req.user.sendEmailFrom }),
        // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
         from: req.user.sendEmailFrom,
        // text: getText(item.name, getEmailTemplate.totalLoanAmount, getEmailTemplate.advisorName, getEmailTemplate.from, passLink, dealSummaryLink),
        text: getText(passLink, dealSummaryLink),
        // eslint-disable-next-line no-shadow
        attachments: getEmailTemplate.emailAttachments.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url ? item.url : item.path,
            fileType: item.fileType,
          };
        }),
        isHtml: true,
        headers,
        isSendDeal: true,
      });
    })
  );

  const result = await LenderPlacement.findOne({ _id: placementId });

  if (result.isEmailSent === EnumOfEmailStatus.SEND_DEAL) {
    const stage = EnumStageOfLenderPlacement.SENT;
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: true,
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
      timeLine: manageLenderPlacementStageTimeline(result.stage, stage, result.timeLine),
    });
  } else {
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: false,
    });
  }
  const stage = EnumStageOfDeal.OUT_IN_MARKET;
  await Deal.findByIdAndUpdate(dealId, {
    stage,
    orderOfStage: stageOfDealWithNumber(stage),
    $push: { timeLine: { stage, updatedAt: new Date() } },
    details: await detailsInDeal(stage, dealId),
  });
  const deal = await Deal.findById(dealId);
  const createActivityLogBody = {
    createdBy: req.user._id,
    updatedBy: req.user._id,
    update: `${deal.dealName} was sent out to lenders`,
    deal: dealId,
    type: EnumOfActivityType.ACTIVITY,
    user: config.activitySystemUser || 'system',
  };
  if (createActivityLogBody.update) {
    await activityLogService.createActivityLog(createActivityLogBody);
  }
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendDealV2 = catchAsync(async (req, res) => {
  const { deals } = req.body;
  const frontEndUrl = config.front.url || 'http://54.196.81.18';
  const admin = req.user;
  const { isFollowUp } = req.query;
  const { emailPresentingPostmark } = admin;
  const advisorEmail = admin.email;
  const promises = await deals.map(async (body) => {
    const { lenderInstitute, deal, lenderPlacement, followUpContent, lender } = body;
    const filterToFindContact = {
      lenderInstitute,
    };
    const filterToFindPlacement = {
      lendingInstitution: lenderInstitute,
      deal,
    };
    const filterToFindDeal = {
      deal,
    };
    const lenderContact = await lenderPlacementService.sendDeal(
      filterToFindContact,
      filterToFindPlacement,
      filterToFindDeal
    );
    const emailBodyValues = {
      dealSummaryLink: `${frontEndUrl}/dealDetail/${deal}?tab=presentation`,
      // TODO: conform & remove from here if not needed
      passLink: `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`,
      advisorName: admin.firstName,
      documents: [],
      executiveSummary: '',
    };
    if (lenderContact.lenderPlacement.lendingInstitution) {
      emailBodyValues.lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
    }
    let totalLoanAmount = 0;
    if (lenderContact.lenderPlacement && lenderContact.lenderPlacement.deal) {
      emailBodyValues.dealName = lenderContact.lenderPlacement.deal.dealName;
      // here loanAmount is coming as $100,000 (string) so we are converting that to number
      totalLoanAmount = lenderContact.lenderPlacement.deal.loanAmount.replace(/[$,]/g, '') * 1;
      // totalLoanAmount is converted into millions so if 1000000 then it should be 1
      totalLoanAmount /= 1000000;
      totalLoanAmount.toFixed(2);
      emailBodyValues.loanAmount = totalLoanAmount;
    }

    const dealSummaryDocs = [];
    if (lenderContact.lenderPlacement.deal.dealSummary && !isFollowUp) {
      if (
        lenderContact.lenderPlacement.deal.dealSummary.documents &&
        lenderContact.lenderPlacement.deal.dealSummary.documents.length
      ) {
        const documentsText = 'Please see attached for deal materials';
        emailBodyValues.documentsText = documentsText;
        dealSummaryDocs.push(...lenderContact.lenderPlacement.deal.dealSummary.documents);
      }
      if (lenderContact.lenderPlacement.deal.dealSummary.executiveSummary && !isFollowUp) {
        emailBodyValues.executiveSummary = lenderContact.lenderPlacement.deal.dealSummary.executiveSummary;
      }
    }

    const { docIds } = lenderContact;

    const lendersDetail = lenderContact.lenderContact.filter((lc) => lc._id.toString() === lender);
    const contact = lendersDetail.map((lc) => {
      return {
        sendTo: lc.email,
        name: lc.firstName,
        _id: lc._id,
      };
    });
    _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
    const staticEmailTemplateData = isFollowUp ? followUpEmailContent() : borrowerSendDealEmailContent();
    let emailTemplate;
    const filter = isFollowUp
      ? {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`,
              `borrowerFollowUpTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        }
      : {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
              `borrowerSendDealTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        };
    emailTemplate = await emailTemplateService.getOne(filter, { populate: 'deal' });
    // if already template not available then we are create
    if (!emailTemplate) {
      emailTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName: admin.firstName,
        contact,
        subject: `${emailBodyValues.dealName}-$${emailBodyValues.loanAmount}m Financing Request`,
        dealDocument: isFollowUp ? [] : docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: !isFollowUp,
        isEmailSent: false,
        totalLoanAmount,
        templateName: isFollowUp
          ? `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`
          : `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
      });
    }
    const getEmailTemplate = emailTemplate;
    const placementId = getEmailTemplate.lenderPlacement;

    const ccList = getEmailTemplate.ccList.map((item) => item);

    const bccList = getEmailTemplate.bccList.map((item) => item);

    const headers = [
      {
        Value: `${placementId}`,
      },
    ];
    const result = await lenderPlacementService.getOne({ _id: placementId });
    // for sending email in the thread we need to pass this header
    if (isFollowUp) {
      headers.push({ Name: 'In-Reply-To', Value: result.postmarkMessageId[0] });
    }

    // todo : make function for this one, and make synchronize so we can handle error coming from that.
    // await Promise.allSettled(
    await asyncForEach(getEmailTemplate.contact, async (item) => {
      let dealSummaryLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary`;
      let passLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`;
      const user = await userService.getOne({ email: item.sendTo, role: enumModel.EnumRoleOfUser.LENDER });
      // TODO: for now done changes here & it will work bcs everytime we got user bcs in send deal if not user than we create the user so no need to create user here but need to move this in the new api of send deal /v3
      const tokens = await tokenService.generateAuthTokens(user);
      dealSummaryLink =`${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&token=${tokens.access.token}`
      passLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true&token=${tokens.access.token}`;
      if (!user) {
        dealSummaryLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        passLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        await invitationService.createInvitation({
          deal,
          invitedBy: admin._id,
          inviteeEmail: item.sendTo,
          role: enumModel.EnumRoleOfUser.LENDER,
        });
      }
      return emailService.sendEmail({
        to: item.sendTo,
        cc: ccList,
        bcc: bccList,
        // for sending email in the thread we need to change subject like this
        subject: isFollowUp ? `RE: ${getEmailTemplate.subject}` : getEmailTemplate.subject,
        // ...(emailPresentingPostmark && { from: req.user.email }),
        // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
        from: req.user.sendEmailFrom,
        text: getTextFromTemplate({
          lenderName: item.name,
          executiveSummary: emailBodyValues.executiveSummary,
          documents: emailBodyValues.documentsText,
          // dealSummaryLink: emailBodyValues.dealSummaryLink,
          dealSummaryLink,
          // passLink: emailBodyValues.passLink,
          passLink,
          advisorName: emailBodyValues.advisorName,
          emailTemplate: getEmailTemplate.emailContent,
          followUpContent: followUpContent || `following up, did you have any feedback on this deal.`,
        }),
        // eslint-disable-next-line no-shadow
        attachments: dealSummaryDocs.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url,
            fileType: item.url.split('.').pop(),
          };
        }),
        isHtml: true,
        headers,
        isSendDeal: true,
        replyTo: req.user.email,
      });
    });
    // );

    // const result = await lenderPlacementService.getOne({ _id: placementId });

    if (result.isEmailSent === enumModel.EnumOfEmailStatus.SEND_DEAL) {
      const stage = enumModel.EnumStageOfLenderPlacement.SENT;
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: true,
          stage,
          stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
          nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
          timeLine: manageLenderPlacementStageTimeline(result.stage, stage, result.timeLine),
        }
      );
    } else {
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: enumModel.EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: false,
        }
      );
    }
    const stage = enumModel.EnumStageOfDeal.OUT_IN_MARKET;
    const dealData = await dealService.updateDeal(
      { _id: deal },
      {
        stage,
        orderOfStage: stageOfDealWithNumber(stage),
        timeLine: manageDealStageTimeline(
          lenderContact.lenderPlacement.deal.stage,
          stage,
          lenderContact.lenderPlacement.deal.timeLine
        ),
        nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
        details: await detailsInDeal(stage, deal),
      },
      { new: true }
    );
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${dealData.dealName} was sent out to lenders`,
      deal,
      type: enumModel.EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  });
  await Promise.all(promises);
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendMessage = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const advisor = req.user;
  const { emailPresentingPostmark } = advisor;
  const { body } = req;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    populate: [
      {
        path: 'deal',
        populate: {
          path: 'dealSummary'
        }
      },
      { path: 'lenderContact' },
    ],
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);

  const emailAttachments = body.documents ? body.documents : [];
  const headers = [
    {
      Value: `${lenderPlacementId}`,
    },
    // for sending email in the thread we need to pass this header
    { Name: 'In-Reply-To', Value: lenderPlacement.postmarkMessageId[0] },
  ];

  // now we are not storing email template in the code
  const subject = getEmailSubjectForDeal(lenderPlacement.deal.dealSummary._doc)

  const response = await emailService.sendEmailUsingGmail({
    to: lenderPlacement.lenderContact.email,
    // for sending email in the thread we need to change subject like this
    subject: `Re: ${subject}`,
    // ...(emailPresentingPostmark && { from: req.user.email }),
    // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
    from: req.user.sendEmailFrom,
    pass: decrypt(req.user.appPassword, config.encryptionPassword),
    text: body.message,
    attachments: emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    }),
    isHtml: false,
    // Headers: [{ Name: 'In-Reply-To', Value: 'originalMessageId@example.com' }],
    headers,
    // when we reply than it should go to sender also & sender is sendEmailFrom
    replyTo: req.user.sendEmailFrom,
  });
  const postmarkMessageId = response.MessageID || response.messageId;
  //Adding postmark message id in placement while updating lender placement when we send message to the lender
  await lenderPlacementService.updateLenderPlacement(
    { _id: lenderPlacementId },
    {
      $push: {
        messages: { sender: advisor.firstName, updatedAt: new Date(), message: body.message, documents: body.documents },
      },
      $addToSet: {
        postmarkMessageId,
      },
    }
  );
  logger.info(`Message successfully sent to ${lenderPlacement.lenderContact.email} from ${req.user.sendEmailFrom} when advisor sent message from manage lender page`);
  return res.status(httpStatus.OK).send({ results: 'Message sent...' });
});

export const getMessages = catchAsync(async (req, res) => {
  const { user } = req
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    select: { messages: 1 },
    new: true,
  };
  // Removed(commented) below line because we have to add the userId in messageReadBy array to mark as user read this message. so we are using update lenderPlacementService and pass the updated lenderPlacement data in the response.
  // const lenderPlacement = await lenderPlacementService.getOne(filter, options);

  // here updating the message is read by user, adding current userId to messageReadBy array so this message is marked as read by the current logged-in user.
  const lenderPlacement = await lenderPlacementService.updateLenderPlacement(filter,  { $addToSet: { 'messages.$[].messageReadBy': user._id }}, options)
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeDocument = catchAsync(async (req, res) => {
  const { lenderPlacementId, documentId } = req.params;
  const query = {
    _id: lenderPlacementId,
  };
  const updates = {
    $pull: {
      'messages.$[].documents': { _id: documentId }, // Remove the document with this _id from the documents array
    },
  };
  await lenderPlacementService.updateLenderPlacement(query, updates);
  return res.status(httpStatus.OK).send({ results: 'Document removed.' });
});

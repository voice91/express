/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import httpStatus from 'http-status';
import {
  s3Service,
  lenderPlacementService,
  emailService,
  emailTemplateService,
  activityLogService,
  lenderContactService,
  dealService,
  userService,
  invitationService,
  taskService,
  tokenService,
} from 'services';
import { catchAsync } from 'utils/catchAsync';
import FileFieldValidationEnum from 'models/fileFieldValidation.model';
import mongoose from 'mongoose';
import TempS3 from 'models/tempS3.model';
import {
  asyncForEach,
  checkTermAdded,
  encodeUrl,
  getEmailSubjectForDeal,
  getStateFullName,
  getTextFromTemplate,
  manageDealStageTimeline,
  manageLenderPlacementStageTimeline,
} from 'utils/common';
import _ from 'lodash';
import { pick } from '../../utils/pick';
import ApiError from '../../utils/ApiError';
import { Deal, EmailTemplate, LenderPlacement, User } from '../../models';
import { borrowerSendDealEmailContent, followUpEmailContent, sendDealTemplate1Text } from '../../utils/emailContent';
import enumModel, {
  EnumOfActivityType,
  EnumOfEmailStatus,
  EnumStageOfDeal,
  EnumStageOfLenderPlacement,
} from '../../models/enum.model';
import config from '../../config/config';
import { stageOfLenderPlacementWithNumber } from '../../utils/enumStageOfLenderPlacement';
import { detailsInDeal } from '../../utils/detailsInDeal';
import { stageOfDealWithNumber } from '../../utils/enumStageForDeal';
import {
  removeLenderPlacementAssociatedThings,
} from "../../services/lenderPlacement.service";

// eslint-disable-next-line import/no-extraneous-dependencies
const he = require('he');

const moveFileAndUpdateTempS3 = async ({ url, newFilePath }) => {
  const newUrl = await s3Service.moveFile({ key: url, newFilePath });
  await TempS3.findOneAndUpdate({ url }, { url: newUrl });
  return newUrl;
};
// this is used to move file to new specified path as shown in basePath, used in create and update controller.
const moveFiles = async ({ body, user, moveFileObj }) => {
  await asyncForEach(Object.keys(moveFileObj), async (key) => {
    const fieldValidation = FileFieldValidationEnum[`${key}OfLenderPlacement`];
    const basePath = `users/${user._id}/lenderPlacement/${body._id}/${key}/${mongoose.Types.ObjectId()}/`;
    if (Array.isArray(moveFileObj[key])) {
      const newUrlsArray = [];
      moveFileObj[key].map(async (ele) => {
        const filePath = `${mongoose.Types.ObjectId()}_${ele.split('/').pop()}`;
        newUrlsArray.push(await moveFileAndUpdateTempS3({ url: ele, newFilePath: basePath + filePath }));
      });
      Object.assign(body, { ...body, [key]: await Promise.all(newUrlsArray) });
    } else {
      const filePath = `${mongoose.Types.ObjectId()}_${moveFileObj[key].split('/').pop()}`;
      Object.assign(body, {
        ...body,
        [key]: await moveFileAndUpdateTempS3({
          url: moveFileObj[key],
          newFilePath: basePath + filePath,
        }),
      });
      if (fieldValidation.generateThumbnails) {
        Object.assign(body, {
          ...body,
          [`thumbOf${key}`]: await s3Service.createThumbnails({
            url: moveFileObj[key],
            resolutions: fieldValidation.thumbnailResolutions,
          }),
        });
      }
    }
  });
};

/**
 * we send the necessary data in this API so FE can show the template to user
 * @type {(function(*, *, *): void)|*}
 */
export const getEmailDataV3 = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.query;
  const filter = {
    _id: {$in:lenderPlacementId},
  };
  const options = {
    populate: [
      { path: 'lenderContact' },
      { path: 'deal',
        populate: {
          path: 'dealSummary',
        },
      },
    ],
  };
  const lenderPlacements = await lenderPlacementService.getLenderPlacementList(filter, options);
  if(lenderPlacementId.length !== lenderPlacements.length) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Some lender placement is not available');
  }
  const hasSameDealId = lenderPlacements.every(
      (placement) => placement.deal.id === lenderPlacements[0].deal.id && placement.lenderContact
  );

  if(!hasSameDealId) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Contact should be selected to send the deal & deal should be same for all the placements');
  }
  const dealSummaryDocs = [];
  if (lenderPlacements[0].deal.dealSummary.documents && lenderPlacements[0].deal.dealSummary.documents.length) {
    dealSummaryDocs.push(...lenderPlacements[0].deal.dealSummary.documents);
  }
  const emailAttachments = dealSummaryDocs.map((item) => {
    return {
      fileName: item.fileName,
      path: item.url,
      fileType: item.url.split('.').pop(),
    };
  });

  const subject = getEmailSubjectForDeal(lenderPlacements[0].deal)
  const response = {
    subject,
    emailAttachments,
    deal: lenderPlacements[0].deal,
    sendTo: lenderPlacements.map((lenderPlacement)=> {
      return {
        name: lenderPlacement.lenderContact.firstName,
        email: lenderPlacement.lenderContact.email
      }}),
    advisorName: req.user.firstName
  }
  return res.status(httpStatus.OK).send({ results: response });
});

/**
 * we are sending email for send deal to lender with email template
 * @type {(function(*, *, *): void)|*}
 */
export const sendEmailV3 = catchAsync(async (req, res) => {
  const { sendToAdvisor } = req.body;

  const { emailPresentingPostmark } = req.user;

  req.body.emailContent = he.decode(req.body.emailContent);

  _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  const dealDetail = await dealService.getOne({_id: req.body.deal})
  const dealId = dealDetail._id;
  if (sendToAdvisor) {
    let firstName = 'lenderName'
    // if we send to multiple placement than send generic lender name else selected lender name
    if(req.body.lenderPlacementIds.length === 1){
      const options = {
        populate: [
          {
            path: 'lenderContact'
          },
        ]
      }
      const lenderPlacement = await lenderPlacementService.getOne({ _id: req.body.lenderPlacementIds[0] }, options);
      firstName = lenderPlacement.lenderContact.firstName
    }
    const isAdvisor = _.template(req.body.emailContent)({
      lenderFirstName: _.startCase(firstName),
      advisorName:_.startCase(req.user.firstName),
      sponsorName: req.user.firstName || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[amount]',
      loanPurpose: dealDetail.loanPurpose || '[loan purpose]',
      dealName: dealDetail.dealName || '[deal name]',
      unitCount: dealDetail.unitCount || '[unitCount]',
      propertyType: dealDetail.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail.address || '[address]',
      city: dealDetail.city || '[city]',
      state: getStateFullName[dealDetail.state] || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx purchasePrice]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      dealSummaryLink: `<a href='#'>Deal Summary</a>`,
      passLink:`<a href='#'>Pass</a>`,
    });
    const emailAttachments = req.body.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });

    await emailService.sendEmail({
      to: req.user.email,
      subject: `TEST - ${req.body.subject}`,
      ...(emailPresentingPostmark && { from: req.user.email }),
      text: isAdvisor,
      attachments: emailAttachments,
      isHtml: true,
      //TODO: check that we need to send placementIds or not bcs now we get array in placementId
      // headers,
    });
    return res.status(httpStatus.OK).send({ results: 'Test-mail sent..' });
  }
  const getText = (passLink, dealSummaryLink, firstName) => {
    const data = _.template(req.body.emailContent)({
      lenderFirstName: _.startCase(firstName),
      advisorName:_.startCase(req.user.firstName),
      sponsorName: _.startCase(req.user.firstName) || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail?.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[x.xx]',
      loanPurpose: dealDetail?.loanPurpose || '[loan purpose]',
      dealName: dealDetail?.dealName || '[deal name]',
      unitCount: dealDetail?.unitCount || '[unitCount]',
      propertyType: dealDetail?.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail?.address || '[address]',
      city: dealDetail?.city || '[city]',
      state: getStateFullName[dealDetail.state] || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      dealSummaryLink: `<a href=${dealSummaryLink}>Deal Summary</a>`,
      passLink:`<a href=${passLink}>Pass</a>`,
    });
    return data;
  };

  // we send email to all selected placement & if we have one than also we are taking in the array
  await Promise.all(
      req.body.lenderPlacementIds.map(async (lenderPlacementId) => {
        const options = {
          populate: [
          { path: 'lenderContact' },
          ]
      }
        const lenderPlacement = await lenderPlacementService.getOne({ _id: lenderPlacementId }, options);
        const frontEndUrl = config.front.url || 'http://54.196.81.18';

        let user = await userService.getOne({ email: lenderPlacement.lenderContact.email, role: enumModel.EnumRoleOfUser.LENDER });
        if (!user) {
          const isLenderContact = await lenderContactService.getOne({ email: lenderPlacement.lenderContact.email }, { populate: 'lenderInstitute' });
          // create user if user has not register
          const userBody = {
            firstName: isLenderContact.firstName,
            companyName: isLenderContact.lenderInstitute.lenderNameVisible,
            lastName: isLenderContact.lastName,
            role: enumModel.EnumRoleOfUser.LENDER,
            enforcePassword: true,
            email: lenderPlacement.lenderContact.email,
            emailVerified: true,
            password: Math.random().toString(36).slice(-10)
          }
          user = await userService.createUser(userBody);
        }
        const tokens = await tokenService.generateAuthTokens(user);
        const dealSummaryLink =`${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&token=${tokens.access.token}`
        const passLink = `${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&pass=true&token=${tokens.access.token}`;
        const headers = [
          {
            Value: `${lenderPlacementId}`,
          },
        ];
        await emailService.sendEmail({
          to: lenderPlacement.lenderContact.email,
          subject: req.body.subject,
          // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
          from: req.user.sendEmailFrom,
          text: getText(passLink, dealSummaryLink, lenderPlacement.lenderContact.firstName),
          attachments: req.body.emailAttachments.map((item) => {
            return {
              fileName: item.fileName,
              path: item.url ? item.url : item.path,
              fileType: item.fileType,
            };
          }),
          isHtml: true,
          headers,
          isSendDeal: true,
        });
        if (lenderPlacement.isEmailSent === EnumOfEmailStatus.SEND_DEAL) {
          const stage = EnumStageOfLenderPlacement.SENT;
          await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
            followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
            isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
            isEmailSentFirstTime: true,
            stage,
            stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
            nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
            timeLine: manageLenderPlacementStageTimeline(lenderPlacement.stage, stage, lenderPlacement.timeLine),
          });
        } else {
          await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
            followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
            isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
            isEmailSentFirstTime: false,
          });
        }
      })
  );

  const stage = EnumStageOfDeal.OUT_IN_MARKET;
  // TODO : need to change here so deal timeLine will update properly
  const deal = await Deal.findByIdAndUpdate(dealId, {
    stage,
    orderOfStage: stageOfDealWithNumber(stage),
    $push: { timeLine: { stage, updatedAt: new Date() } },
    details: await detailsInDeal(stage, dealId),
  }, {new: true});
  const createActivityLogBody = {
    createdBy: req.user._id,
    updatedBy: req.user._id,
    update: `${deal.dealName} was sent out to lenders`,
    deal: dealId,
    type: EnumOfActivityType.ACTIVITY,
    user: config.activitySystemUser || 'system',
  };
  await activityLogService.createActivityLog(createActivityLogBody);
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const get = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    populate: [
      { path: 'lendingInstitution' },
      { path: 'notes', match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE } },
    ],
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});
const getLenderPlacementFilterQuery = (query) => {
  const filter = pick(query, ['deal', 'stage', 'isFavourite', 'isArchived']);
  if (query.search) {
    filter.$or = [{ firstName: new RegExp(query.search, 'i') }, { lastName: new RegExp(query.search, 'i') }];
  }
  return filter;
};
export const list = catchAsync(async (req, res) => {
  const { query } = req;
  const queryParams = getLenderPlacementFilterQuery(query);

  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    isFavourite: 'desc',
    [sortingObj.sort]: sortingObj.order,
  };

  const filter = {
    ...queryParams,
    stage: query.stage ? query.stage : { $ne: EnumStageOfLenderPlacement.ARCHIVE },
  };
  const options = {
    ...pick(query, ['sort', 'limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'outstandingTaskCount',
        count: true,
        match: {
          deal: query.deal,
          isCompleted: false,
        },
      },
      {
        path: 'notes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE },
      },
      {
        path: 'internalNotes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.INTERNAL_NOTE },
      },
    ],
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
    options.collation = { locale: 'en', caseLevel: false }; // Case-insensitive sorting
  }
  let lenderPlacement = await lenderPlacementService.getLenderPlacementList(filter, options);
  // filter out if we only need outstanding tasks placement
  // if we want to find according to it than DB query will be increase & it takes more time bcs we are counting outstandingTaskCount by virtual & matching
  if (query.outstandingTask) {
    lenderPlacement = lenderPlacement.filter((placement) => placement.outstandingTaskCount > 0);
  }
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const paginate = catchAsync(async (req, res) => {
  const { query } = req;
  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    [sortingObj.sort]: sortingObj.order,
  };
  const filter = { ...pick(query, ['deal']) };
  const options = {
    ...pick(query, ['limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'notes',
      },
    ],
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
  }
  const lenderPlacement = await lenderPlacementService.getLenderPlacementListWithPagination(filter, options);
  lenderPlacement.results = lenderPlacement.results.map((lenderPlacementObject) => ({
    createdAt: lenderPlacementObject.createdAt,
    ...lenderPlacementObject.toJSON(),
  }));
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const create = catchAsync(async (req, res) => {
  const { body } = req;
  body.createdBy = req.user._id;
  body.updatedBy = req.user._id;
  const { user } = req;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet }),
  };
  if (body.stage) {
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
  }

  body._id = mongoose.Types.ObjectId();
  await moveFiles({ body, user, moveFileObj });
  const options = {};
  // Before it wasn't allowing other institute to add as well even if one is already added, so using promise.all so that it'll throw error for one but will allow others to get added in deal
  await Promise.all(
    body.lendingDetails.map(async (lendingInstitute) => {
      const placement = {
        ...lendingInstitute,
        createdBy: body.createdBy,
        updatedBy: body.updatedBy,
      };
      const lenderPlacementResult = await lenderPlacementService.createLenderPlacement(placement, options);

      if (lenderPlacementResult) {
        const uploadedFileUrls = [];
        uploadedFileUrls.push(lenderPlacementResult.termSheet);
        await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
      }
    })
  );
  return res.status(httpStatus.CREATED).send({ results: 'Lender added to the deal' });
});

export const update = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user._id;
  const { lenderPlacementId } = req.params;
  const { user } = req;
  const termsheet = body.termSheet;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet.url }),
  };
  body._id = lenderPlacementId;
  await moveFiles({ body, user, moveFileObj });
  const filter = {
    _id: lenderPlacementId,
  };
  if (body.termSheet) {
    const { fileName } = termsheet;
    body.termSheet = encodeUrl(body.termSheet);
    body.termSheet = { url: body.termSheet, fileName };
  }
  if (body.terms) {
    const futureFunding = body.terms.futureFunding ? body.terms.futureFunding : 0;
    body.terms.totalLoanAmount = body.terms.initialFunding + futureFunding;
  }

  const options = {
    new: true,
    populate: [
      { path: 'lendingInstitution' },
      { path: 'lenderContact' },
      // TODO : check & add condition here like in the getlist API & also check for outstanding task bcs it will be 0 when we change status to new & after changing status FE is calling getList API so they are getting updated data
      {
        path: 'internalNotes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.INTERNAL_NOTE },
      },
      { path: 'notes' },
      { path: 'lenderAllContacts' },
      { path: 'deal' },
    ],
  };
  const beforeLenderPlacementResult = await lenderPlacementService.getLenderPlacementById(lenderPlacementId);

  // check & throw error if term is not added
  // bcs we have requirement that if term is added than only we can add term-sheet
  if (body.termSheet) {
    checkTermAdded(beforeLenderPlacementResult);
  }

  const oldStage = beforeLenderPlacementResult.stage;

  if (body.stage) {
    // we change the isEmailSent to same as what we have when we add lender bcs if we don't change than it will not chane stage of deal & timeline when we send the deal after changing stage
    if (body.stage === enumModel.EnumStageOfDeal.NEW) {
      body.isEmailSent = enumModel.EnumOfEmailStatus.SEND_DEAL;
      // When we change the status from sent to new then all the messages , contact, task, postmarkMessageId and sendEmailPostmarkMessageId should get removed
      body.messages = [];
      body.$unset = { lenderContact: '' };
      body.postmarkMessageId = [];
      body.sendEmailPostmarkMessageId = [];
      await removeLenderPlacementAssociatedThings(beforeLenderPlacementResult)
    }
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
    body.nextStep = body.nextStep ? body.nextStep : enumModel.EnumNextStepOfLenderPlacement[body.stage];
    body.timeLine = manageLenderPlacementStageTimeline(oldStage, body.stage, beforeLenderPlacementResult.timeLine);
  }
  if (oldStage !== EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Only Archive possible when status changed from Closed to Archive..');
  }
  if (oldStage === EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage: EnumStageOfLenderPlacement.ARCHIVE,
    });
  }
  const lenderPlacementResult = await lenderPlacementService.updateLenderPlacement(filter, body, options);
  const dealId = lenderPlacementResult.deal;
  if (lenderPlacementResult.stage === enumModel.EnumStageOfLenderPlacement.CLOSING) {
    const stage = enumModel.EnumStageOfDeal.CLOSING;
    await Deal.findByIdAndUpdate(dealId, {
      stage,
      orderOfStage: stageOfDealWithNumber(stage),
      timeLine: manageDealStageTimeline(lenderPlacementResult.deal.stage, stage, lenderPlacementResult.deal.timeLine),
      details: await detailsInDeal(stage, dealId),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${lenderPlacementResult.deal.dealName} moved into closing with ${lenderPlacementResult.lendingInstitution.lenderNameVisible}`,
      deal: dealId,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  }
  // tempS3
  if (lenderPlacementResult.termSheet) {
    const uploadedFileUrls = [];
    uploadedFileUrls.push(lenderPlacementResult.termSheet.url);
    await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
  }
  // if termSheet added for first time than only we add activity logs and update lenderPlacement stage to termSheet Received
  if (!beforeLenderPlacementResult.termSheet && body.termSheet) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} posted a term sheet on ${lenderPlacementResult.deal.dealName}`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_SHEET_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }

  // if terms added for first time than only we add activity logs and update lenderPlacement stage to terms Received
  if (!beforeLenderPlacementResult.terms && body.terms) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} sent over terms`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }

  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const updateMany = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user;
  const { lenderPlacementIds } = req.body;
  const updateBody = req.body.update;
  const filter = {
    _id: { $in: lenderPlacementIds },
  };
  const options = { new: true };
  const lenderPlacementResult = await lenderPlacementService.updateManyLenderPlacement(filter, updateBody, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const remove = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeByDealAndLendingInstitution = catchAsync(async (req, res) => {
  const { deal, lendingInstitution } = req.query;
  const filter = {
    deal,
    lendingInstitution,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const sendDeal = catchAsync(async (req, res) => {
  const { lenderInstitute, deal, lenderPlacement } = req.body;
  const advisorName = req.user.name;
  const advisorEmail = req.user.email;
  const filterToFindContact = {
    lenderInstitute,
  };
  const filterToFindPlacement = {
    // lendingInstitution: lenderInstitute,
    _id: lenderPlacement,
  };
  const filterToFindDeal = {
    deal,
  };
  const lenderContact = await lenderPlacementService.sendDeal(filterToFindContact, filterToFindPlacement, filterToFindDeal);

  let lenderName;
  if (lenderContact.lenderPlacement.lendingInstitution) {
    lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
  }

  let totalLoanAmount = 0;
  const { docIds } = lenderContact;
  const createTemplates = [];

  if (!lenderContact.lenderPlacement.terms) {
    totalLoanAmount = 0;
  } else {
    totalLoanAmount = lenderContact.lenderPlacement.terms.totalLoanAmount;
    totalLoanAmount /= 1000000;
    totalLoanAmount = totalLoanAmount.toFixed(2);
  }

  if (lenderPlacement) {
    // now we have only on contact in placement so no need to add all contact
    const contact = [
      {
        sendTo: lenderContact.lenderPlacement.lenderContact.email,
        name: lenderContact.lenderPlacement.lenderContact.firstName,
      },
    ];
    const staticEmailTemplateData = sendDealTemplate1Text();
    const templateData = await EmailTemplate.find({
      lenderPlacement,
      isFirstTime: true,
    });

    let totalLoanAmountForSubject = lenderContact.lenderPlacement.deal.loanAmount.replace(/[$,]/g, '') * 1;
    // totalLoanAmount is converted into millions so if 1000000 then it should be 1
    totalLoanAmountForSubject /= 1000000;
    totalLoanAmountForSubject.toFixed(2);

    if (!templateData.length) {
      // TODO : we can remove the template things when we get time
      const defaultTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName,
        contact,
        // subject: '547 Valley Road - $1.5m Acquisition Financing',
        subject: `${lenderContact.lenderPlacement.deal.dealName}-$${totalLoanAmountForSubject}m Financing Request`,
        dealDocument: docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: true,
        isEmailSent: false,
        totalLoanAmount,
        templateName: `defaultTemplate - ${lenderName}`,
      });
      // create only one template for now
      // const blankTemplate = await EmailTemplate.create({
      //   from: advisorEmail,
      //   advisorName,
      //   contact,
      //   subject: '',
      //   dealDocument: docIds,
      //   emailContent: '',
      //   lenderPlacement,
      //   deal,
      //   emailAttachments: [],
      //   isFirstTime: true,
      //   isEmailSent: false,
      //   isBlankTemplate: true,
      //   templateName: `blankTemplate - ${lenderName}`,
      // });
      // createTemplates.push(defaultTemplate, blankTemplate);
      createTemplates.push(defaultTemplate);
    }
  }
  return res.status(httpStatus.OK).send({ createTemplates });
});

export const getEmailTemplatesByLanderPlacementId = catchAsync(async (req, res) => {
  const { lenderPlacement } = req.params;
  const filter = {
    lenderPlacement,
  };

  const emailTemplate = await emailTemplateService.getEmailTemplateList(filter);
  return res.status(httpStatus.OK).send({ results: emailTemplate });
});

export const getTemplateByTemplateId = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const options = {
    populate: [
      {
        path: 'deal',
        populate: {
          path: 'dealSummary',
        },
      },
    ],
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter, {}, options);
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id!');
  }
  // need to send attachment so getting all attachment of dealSummary
  const dealSummaryDocs = [];
  if (getEmailTemplate.deal.dealSummary.documents && getEmailTemplate.deal.dealSummary.documents.length) {
    dealSummaryDocs.push(...getEmailTemplate.deal.dealSummary.documents);
  }
  const emailAttachments = dealSummaryDocs.map((item) => {
    return {
      fileName: item.fileName,
      path: item.url,
      fileType: item.url.split('.').pop(),
    };
  });
  getEmailTemplate.emailAttachments = emailAttachments;
  return res.status(httpStatus.OK).send({ getEmailTemplate });
});

export const updateAndSaveInitialEmailContent = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter).lean();
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  if (req.body.templateName === getEmailTemplate.templateName) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'A template with the same name already exists..');
  }

  const body = {
    ...getEmailTemplate,
  };
  delete body._id;

  const emailContent = req.body.emailContent ? req.body.emailContent : body.emailContent;

  const updatedBody = {
    ...body,
    ...req.body,
    ...{ lenderPlacement: getEmailTemplate.lenderPlacement },
    ...{ isFirstTime: false },
    ...{
      /*
       * he (for “HTML entities”) is a robust HTML entity encoder/decoder written in JavaScript
       * */
      emailContent: he.decode(emailContent),
    },
  };

  if (updatedBody.emailAttachments) {
    const emailAttachments = updatedBody.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });
    delete updatedBody.emailAttachments;
    updatedBody.emailAttachments = emailAttachments;
  }
  if (updatedBody.sendTo) {
    const result = updatedBody.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (updatedBody.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = updatedBody.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }

          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);
          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      updatedBody.contact = data;
    } else {
      updatedBody.contact = result;
    }
    delete updatedBody.sendTo;
  }

  const templateData = await EmailTemplate.create(updatedBody);

  return res.status(httpStatus.OK).send({ templateData });
});

export const sendEmail = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;
  const { sendToAdvisor } = req.body;
  const filter = {
    _id: emailTemplateId,
  };
  const getUser = await User.findOne({ _id: req.user._id });
  const { emailPresentingPostmark } = getUser;
  const emailTemplate = await EmailTemplate.findOne(filter).lean().populate('deal');

  if (!emailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  let getEmailTemplate;
  if (req.body.getEmailTemplate) {
    getEmailTemplate = req.body.getEmailTemplate;
    const result = getEmailTemplate.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (emailTemplate.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = emailTemplate.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }
          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);

          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      getEmailTemplate.contact = data;
    } else {
      getEmailTemplate.contact = result;
    }
    delete getEmailTemplate.sendTo;
    if (getEmailTemplate.emailContent) {
      getEmailTemplate.emailContent = he.decode(getEmailTemplate.emailContent);
    }
  } else {
    getEmailTemplate = emailTemplate;
  }

  const placementId = getEmailTemplate.lenderPlacement;

  const dealId = emailTemplate.deal._id;

  const ccList = getEmailTemplate.ccList.map((item) => item);

  const bccList = getEmailTemplate.bccList.map((item) => item);

  const headers = [
    {
      Value: `${placementId}`,
    },
  ];

  const sendToIsEmpty = getEmailTemplate.contact.map((item) => item.sendTo);
  _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  if (sendToIsEmpty.length === 0) {
    return res.status(httpStatus.OK).send({ results: 'No email addresses to send to.' });
  }
  const dealDetail = emailTemplate.deal
  if (sendToAdvisor) {
    const isAdvisor = _.template(getEmailTemplate.emailContent)({
      // userFirstName: req.user.firstName,
      // totalLoanAmount: getEmailTemplate.totalLoanAmount,
      // advisorName: req.user.firstName,
      // advisorEmail: req.user.email,
      sponsorName: emailTemplate.advisorName || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[amount]',
      loanPurpose: dealDetail.loanPurpose || '[loan purpose]',
      dealName: dealDetail.dealName || '[deal name]',
      unitCount: dealDetail.unitCount || '[unitCount]',
      propertyType: dealDetail.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail.address || '[address]',
      city: dealDetail.city || '[city]',
      state: getStateFullName[dealDetail.state] || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx purchasePrice]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      passLink:"",
      dealSummaryLink: "",
    });
    const emailAttachments = getEmailTemplate.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });

    await emailService.sendEmail({
      to: req.user.email,
      subject: `TEST - ${getEmailTemplate.subject}`,
      ...(emailPresentingPostmark && { from: req.user.email }),
      text: isAdvisor,
      attachments: emailAttachments,
      isHtml: true,
      headers,
    });
    return res.status(httpStatus.OK).send({ results: 'Test-mail sent..' });
  }
  const getText = (passLink, dealSummaryLink) => {
    // const getText = (userFirstName, totalLoanAmount, advisorName, advisorEmail) => {
    const data = _.template(getEmailTemplate.emailContent)({
      // userFirstName,
      // totalLoanAmount,
      // advisorName,
      // advisorEmail,
      sponsorName: emailTemplate.advisorName || '[Sponsor Name]',
      amount: (parseFloat(String(dealDetail?.loanAmount)?.replaceAll(/[$,]/g, '')) || 0) / 1000000 || '[x.xx]',
      loanPurpose: dealDetail?.loanPurpose || '[loan purpose]',
      dealName: dealDetail?.dealName || '[deal name]',
      unitCount: dealDetail?.unitCount || '[unitCount]',
      propertyType: dealDetail?.assetType || '[propertyType]',
      toBeBuilt: '[to-be-built]',
      address: dealDetail?.address || '[address]',
      city: dealDetail?.city || '[city]',
      state: getStateFullName[dealDetail.state] || '[state]',
      purchasePrice:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'purchasePrice')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      inPlaceNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'inPlaceNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      stabilizedNOI:
          (parseFloat(String(_.find(dealDetail?.loanInformation, (data) => data?.key === 'stabilizedNOI')?.value)?.replaceAll(/[$,]/g, '')) || 0) /
          1000000 || '[x.xx]',
      dealSummaryLink: `<a href=${dealSummaryLink}>Deal Summary</a>`,
      passLink:`<a href=${passLink}>Pass</a>`,
    });
    return data;
  };

  // todo : make function for this one, and make synchronize so we can handle error coming from that.
  await Promise.allSettled(
    getEmailTemplate.contact.map(async (item, index) => {
      const frontEndUrl = config.front.url || 'http://54.196.81.18';

      let user = await userService.getOne({ email: item.sendTo, role: enumModel.EnumRoleOfUser.LENDER });
      if (!user) {
        const isLenderContact = await lenderContactService.getOne({ email: item.sendTo }, { populate: 'lenderInstitute' });
        // create user if user has not register
        const userBody = {
          firstName: isLenderContact.firstName,
          companyName: isLenderContact.lenderInstitute.lenderNameVisible,
          lastName: isLenderContact.lastName,
          role: enumModel.EnumRoleOfUser.LENDER,
          enforcePassword: true,
          email: item.sendTo,
          emailVerified: true,
          password: Math.random().toString(36).slice(-10)
        }
        user = await userService.createUser(userBody);
      }
      const tokens = await tokenService.generateAuthTokens(user);
      const dealSummaryLink =`${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&token=${tokens.access.token}`
      const passLink = `${frontEndUrl}/dealDetail/${dealId}?tab=dealSummary&pass=true&token=${tokens.access.token}`;
      return emailService.sendEmail({
        to: item.sendTo,
        // bcs we want that email to cc & bcc will go to only once
        ...(index === 0 && {cc: ccList, bcc: bccList}),
        subject: getEmailTemplate.subject,
        // ...(emailPresentingPostmark && { from: req.user.sendEmailFrom }),
        // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
         from: req.user.sendEmailFrom,
        // text: getText(item.name, getEmailTemplate.totalLoanAmount, getEmailTemplate.advisorName, getEmailTemplate.from, passLink, dealSummaryLink),
        text: getText(passLink, dealSummaryLink),
        // eslint-disable-next-line no-shadow
        attachments: getEmailTemplate.emailAttachments.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url ? item.url : item.path,
            fileType: item.fileType,
          };
        }),
        isHtml: true,
        headers,
        isSendDeal: true,
      });
    })
  );

  const result = await LenderPlacement.findOne({ _id: placementId });

  if (result.isEmailSent === EnumOfEmailStatus.SEND_DEAL) {
    const stage = EnumStageOfLenderPlacement.SENT;
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: true,
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
      timeLine: manageLenderPlacementStageTimeline(result.stage, stage, result.timeLine),
    });
  } else {
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: false,
    });
  }
  const stage = EnumStageOfDeal.OUT_IN_MARKET;
  await Deal.findByIdAndUpdate(dealId, {
    stage,
    orderOfStage: stageOfDealWithNumber(stage),
    $push: { timeLine: { stage, updatedAt: new Date() } },
    details: await detailsInDeal(stage, dealId),
  });
  const deal = await Deal.findById(dealId);
  const createActivityLogBody = {
    createdBy: req.user._id,
    updatedBy: req.user._id,
    update: `${deal.dealName} was sent out to lenders`,
    deal: dealId,
    type: EnumOfActivityType.ACTIVITY,
    user: config.activitySystemUser || 'system',
  };
  if (createActivityLogBody.update) {
    await activityLogService.createActivityLog(createActivityLogBody);
  }
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendDealV2 = catchAsync(async (req, res) => {
  const { deals } = req.body;
  const frontEndUrl = config.front.url || 'http://54.196.81.18';
  const admin = req.user;
  const { isFollowUp } = req.query;
  const { emailPresentingPostmark } = admin;
  const advisorEmail = admin.email;
  const promises = await deals.map(async (body) => {
    const { lenderInstitute, deal, lenderPlacement, followUpContent, lender } = body;
    const filterToFindContact = {
      lenderInstitute,
    };
    const filterToFindPlacement = {
      lendingInstitution: lenderInstitute,
      deal,
    };
    const filterToFindDeal = {
      deal,
    };
    const lenderContact = await lenderPlacementService.sendDeal(
      filterToFindContact,
      filterToFindPlacement,
      filterToFindDeal
    );
    const emailBodyValues = {
      dealSummaryLink: `${frontEndUrl}/dealDetail/${deal}?tab=presentation`,
      // TODO: conform & remove from here if not needed
      passLink: `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`,
      advisorName: admin.firstName,
      documents: [],
      executiveSummary: '',
    };
    if (lenderContact.lenderPlacement.lendingInstitution) {
      emailBodyValues.lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
    }
    let totalLoanAmount = 0;
    if (lenderContact.lenderPlacement && lenderContact.lenderPlacement.deal) {
      emailBodyValues.dealName = lenderContact.lenderPlacement.deal.dealName;
      // here loanAmount is coming as $100,000 (string) so we are converting that to number
      totalLoanAmount = lenderContact.lenderPlacement.deal.loanAmount.replace(/[$,]/g, '') * 1;
      // totalLoanAmount is converted into millions so if 1000000 then it should be 1
      totalLoanAmount /= 1000000;
      totalLoanAmount.toFixed(2);
      emailBodyValues.loanAmount = totalLoanAmount;
    }

    const dealSummaryDocs = [];
    if (lenderContact.lenderPlacement.deal.dealSummary && !isFollowUp) {
      if (
        lenderContact.lenderPlacement.deal.dealSummary.documents &&
        lenderContact.lenderPlacement.deal.dealSummary.documents.length
      ) {
        const documentsText = 'Please see attached for deal materials';
        emailBodyValues.documentsText = documentsText;
        dealSummaryDocs.push(...lenderContact.lenderPlacement.deal.dealSummary.documents);
      }
      if (lenderContact.lenderPlacement.deal.dealSummary.executiveSummary && !isFollowUp) {
        emailBodyValues.executiveSummary = lenderContact.lenderPlacement.deal.dealSummary.executiveSummary;
      }
    }

    const { docIds } = lenderContact;

    const lendersDetail = lenderContact.lenderContact.filter((lc) => lc._id.toString() === lender);
    const contact = lendersDetail.map((lc) => {
      return {
        sendTo: lc.email,
        name: lc.firstName,
        _id: lc._id,
      };
    });
    _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
    const staticEmailTemplateData = isFollowUp ? followUpEmailContent() : borrowerSendDealEmailContent();
    let emailTemplate;
    const filter = isFollowUp
      ? {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`,
              `borrowerFollowUpTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        }
      : {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
              `borrowerSendDealTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        };
    emailTemplate = await emailTemplateService.getOne(filter, { populate: 'deal' });
    // if already template not available then we are create
    if (!emailTemplate) {
      emailTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName: admin.firstName,
        contact,
        subject: `${emailBodyValues.dealName}-$${emailBodyValues.loanAmount}m Financing Request`,
        dealDocument: isFollowUp ? [] : docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: !isFollowUp,
        isEmailSent: false,
        totalLoanAmount,
        templateName: isFollowUp
          ? `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`
          : `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
      });
    }
    const getEmailTemplate = emailTemplate;
    const placementId = getEmailTemplate.lenderPlacement;

    const ccList = getEmailTemplate.ccList.map((item) => item);

    const bccList = getEmailTemplate.bccList.map((item) => item);

    const headers = [
      {
        Value: `${placementId}`,
      },
    ];
    const result = await lenderPlacementService.getOne({ _id: placementId });
    // for sending email in the thread we need to pass this header
    if (isFollowUp) {
      headers.push({ Name: 'In-Reply-To', Value: result.postmarkMessageId[0] });
    }

    // todo : make function for this one, and make synchronize so we can handle error coming from that.
    // await Promise.allSettled(
    await asyncForEach(getEmailTemplate.contact, async (item) => {
      let dealSummaryLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary`;
      let passLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`;
      const user = await userService.getOne({ email: item.sendTo, role: enumModel.EnumRoleOfUser.LENDER });
      if (!user) {
        dealSummaryLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        passLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        await invitationService.createInvitation({
          deal,
          invitedBy: admin._id,
          inviteeEmail: item.sendTo,
          role: enumModel.EnumRoleOfUser.LENDER,
        });
      }
      return emailService.sendEmail({
        to: item.sendTo,
        cc: ccList,
        bcc: bccList,
        // for sending email in the thread we need to change subject like this
        subject: isFollowUp ? `RE: ${getEmailTemplate.subject}` : getEmailTemplate.subject,
        // ...(emailPresentingPostmark && { from: req.user.email }),
        // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
        from: req.user.sendEmailFrom,
        text: getTextFromTemplate({
          lenderName: item.name,
          executiveSummary: emailBodyValues.executiveSummary,
          documents: emailBodyValues.documentsText,
          // dealSummaryLink: emailBodyValues.dealSummaryLink,
          dealSummaryLink,
          // passLink: emailBodyValues.passLink,
          passLink,
          advisorName: emailBodyValues.advisorName,
          emailTemplate: getEmailTemplate.emailContent,
          followUpContent: followUpContent || `following up, did you have any feedback on this deal.`,
        }),
        // eslint-disable-next-line no-shadow
        attachments: dealSummaryDocs.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url,
            fileType: item.url.split('.').pop(),
          };
        }),
        isHtml: true,
        headers,
        isSendDeal: true,
        replyTo: req.user.email,
      });
    });
    // );

    // const result = await lenderPlacementService.getOne({ _id: placementId });

    if (result.isEmailSent === enumModel.EnumOfEmailStatus.SEND_DEAL) {
      const stage = enumModel.EnumStageOfLenderPlacement.SENT;
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: true,
          stage,
          stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
          nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
          timeLine: manageLenderPlacementStageTimeline(result.stage, stage, result.timeLine),
        }
      );
    } else {
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: enumModel.EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: false,
        }
      );
    }
    const stage = enumModel.EnumStageOfDeal.OUT_IN_MARKET;
    const dealData = await dealService.updateDeal(
      { _id: deal },
      {
        stage,
        orderOfStage: stageOfDealWithNumber(stage),
        timeLine: manageDealStageTimeline(
          lenderContact.lenderPlacement.deal.stage,
          stage,
          lenderContact.lenderPlacement.deal.timeLine
        ),
        nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
        details: await detailsInDeal(stage, deal),
      },
      { new: true }
    );
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${dealData.dealName} was sent out to lenders`,
      deal,
      type: enumModel.EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  });
  await Promise.all(promises);
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendMessage = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const advisor = req.user;
  const { emailPresentingPostmark } = advisor;
  const { body } = req;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    populate: {
      path: 'deal'
    }
  }
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  const lenderContact = await lenderContactService.getOne(
    {
      lenderInstitute: lenderPlacement.lendingInstitution,
    },
    { populate: 'lenderInstitute' }
  );
  const emailAttachments = body.documents ? body.documents : [];
  const headers = [
    {
      Value: `${lenderPlacementId}`,
    },
    // for sending email in the thread we need to pass this header
    { Name: 'In-Reply-To', Value: lenderPlacement.postmarkMessageId[0] },
  ];

  // now we are not storing email template in the code
  const subject = getEmailSubjectForDeal(lenderPlacement.deal)

  await emailService.sendEmail({
    to: lenderContact.email,
    // for sending email in the thread we need to change subject like this
    subject: `Re: ${subject}`,
    // ...(emailPresentingPostmark && { from: req.user.email }),
    // we will need to send email from this email if not present than it will take default email we have that condition in the sendEmail function
    from: req.user.sendEmailFrom,
    text: body.message,
    attachments: emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    }),
    isHtml: false,
    // Headers: [{ Name: 'In-Reply-To', Value: 'originalMessageId@example.com' }],
    headers,
    replyTo: req.user.email,
  });
  await lenderPlacementService.updateLenderPlacement(
    { _id: lenderPlacementId },
    {
      $push: {
        messages: { sender: advisor.firstName, updatedAt: new Date(), message: body.message, documents: body.documents },
      },
    }
  );
  return res.status(httpStatus.OK).send({ results: 'Message sent...' });
});

export const getMessages = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    select: { messages: 1 },
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeDocument = catchAsync(async (req, res) => {
  const { lenderPlacementId, documentId } = req.params;
  const query = {
    _id: lenderPlacementId,
  };
  const updates = {
    $pull: {
      'messages.$[].documents': { _id: documentId }, // Remove the document with this _id from the documents array
    },
  };
  await lenderPlacementService.updateLenderPlacement(query, updates);
  return res.status(httpStatus.OK).send({ results: 'Document removed.' });
});

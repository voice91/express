/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import httpStatus from 'http-status';
import {
  s3Service,
  lenderPlacementService,
  emailService,
  emailTemplateService,
  activityLogService,
  lenderContactService,
  dealService,
  userService,
  invitationService,
} from 'services';
import { catchAsync } from 'utils/catchAsync';
import FileFieldValidationEnum from 'models/fileFieldValidation.model';
import mongoose from 'mongoose';
import TempS3 from 'models/tempS3.model';
import {
  asyncForEach,
  encodeUrl,
  getTextFromTemplate,
  manageDealStageTimeline,
  manageLenderPlacementStageTimeline,
} from 'utils/common';
import _ from 'lodash';
import { pick } from '../../utils/pick';
import ApiError from '../../utils/ApiError';
import { Deal, EmailTemplate, LenderPlacement, User } from '../../models';
import { borrowerSendDealEmailContent, followUpEmailContent, sendDealTemplate1Text } from '../../utils/emailContent';
import enumModel, {
  EnumOfActivityType,
  EnumOfEmailStatus,
  EnumStageOfDeal,
  EnumStageOfLenderPlacement,
} from '../../models/enum.model';
import config from '../../config/config';
import { stageOfLenderPlacementWithNumber } from '../../utils/enumStageOfLenderPlacement';
import { detailsInDeal } from '../../utils/detailsInDeal';
import { stageOfDealWithNumber } from '../../utils/enumStageForDeal';

// eslint-disable-next-line import/no-extraneous-dependencies
const he = require('he');

const moveFileAndUpdateTempS3 = async ({ url, newFilePath }) => {
  const newUrl = await s3Service.moveFile({ key: url, newFilePath });
  await TempS3.findOneAndUpdate({ url }, { url: newUrl });
  return newUrl;
};
// this is used to move file to new specified path as shown in basePath, used in create and update controller.
const moveFiles = async ({ body, user, moveFileObj }) => {
  await asyncForEach(Object.keys(moveFileObj), async (key) => {
    const fieldValidation = FileFieldValidationEnum[`${key}OfLenderPlacement`];
    const basePath = `users/${user._id}/lenderPlacement/${body._id}/${key}/${mongoose.Types.ObjectId()}/`;
    if (Array.isArray(moveFileObj[key])) {
      const newUrlsArray = [];
      moveFileObj[key].map(async (ele) => {
        const filePath = `${mongoose.Types.ObjectId()}_${ele.split('/').pop()}`;
        newUrlsArray.push(await moveFileAndUpdateTempS3({ url: ele, newFilePath: basePath + filePath }));
      });
      Object.assign(body, { ...body, [key]: await Promise.all(newUrlsArray) });
    } else {
      const filePath = `${mongoose.Types.ObjectId()}_${moveFileObj[key].split('/').pop()}`;
      Object.assign(body, {
        ...body,
        [key]: await moveFileAndUpdateTempS3({
          url: moveFileObj[key],
          newFilePath: basePath + filePath,
        }),
      });
      if (fieldValidation.generateThumbnails) {
        Object.assign(body, {
          ...body,
          [`thumbOf${key}`]: await s3Service.createThumbnails({
            url: moveFileObj[key],
            resolutions: fieldValidation.thumbnailResolutions,
          }),
        });
      }
    }
  });
};
export const get = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    populate: [
      { path: 'lendingInstitution' },
      { path: 'notes', match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE } },
    ],
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});
const getLenderPlacementFilterQuery = (query) => {
  const filter = pick(query, ['deal', 'stage', 'isFavourite', 'isArchived']);
  if (query.search) {
    filter.$or = [{ firstName: new RegExp(query.search, 'i') }, { lastName: new RegExp(query.search, 'i') }];
  }
  return filter;
};
export const list = catchAsync(async (req, res) => {
  const { query } = req;
  const queryParams = getLenderPlacementFilterQuery(query);

  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    isFavourite: 'desc',
    [sortingObj.sort]: sortingObj.order,
  };

  const filter = {
    ...queryParams,
    stage: query.stage ? query.stage : { $ne: EnumStageOfLenderPlacement.ARCHIVE },
  };
  const options = {
    ...pick(query, ['sort', 'limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'outstandingTaskCount',
        count: true,
        match: {
          deal: query.deal,
          isCompleted: false,
        },
      },
      {
        path: 'notes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.EXTERNAL_NOTE },
      },
      {
        path: 'internalNotes',
        populate: [{ path: 'user' }],
        match: { notesType: enumModel.EnumOfNotesTypeOfLenderNotes.INTERNAL_NOTE },
      },
    ],
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
    options.collation = { locale: 'en', caseLevel: false }; // Case-insensitive sorting
  }
  const lenderPlacement = await lenderPlacementService.getLenderPlacementList(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const paginate = catchAsync(async (req, res) => {
  const { query } = req;
  const sortingObj = pick(query, ['sort', 'order']);
  const sortObj = {
    [sortingObj.sort]: sortingObj.order,
  };
  const filter = { ...pick(query, ['deal']) };
  const options = {
    ...pick(query, ['limit', 'page']),
    populate: [
      {
        path: 'lendingInstitution',
      },
      {
        path: 'lenderContact',
      },
      {
        path: 'lenderAllContacts',
      },
      {
        path: 'notes',
      },
    ],
  };
  if (sortingObj.sort) {
    options.sort = sortObj;
  }
  const lenderPlacement = await lenderPlacementService.getLenderPlacementListWithPagination(filter, options);
  lenderPlacement.results = lenderPlacement.results.map((lenderPlacementObject) => ({
    createdAt: lenderPlacementObject.createdAt,
    ...lenderPlacementObject.toJSON(),
  }));
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const create = catchAsync(async (req, res) => {
  const { body } = req;
  body.createdBy = req.user._id;
  body.updatedBy = req.user._id;
  const { user } = req;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet }),
  };
  if (body.stage) {
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
  }

  body._id = mongoose.Types.ObjectId();
  await moveFiles({ body, user, moveFileObj });
  const options = {};
  // Before it wasn't allowing other institute to add as well even if one is already added, so using promise.all so that it'll throw error for one but will allow others to get added in deal
  await Promise.all(
    body.lendingDetails.map(async (lendingInstitute) => {
      const placement = {
        ...lendingInstitute,
        createdBy: body.createdBy,
        updatedBy: body.updatedBy,
      };
      const lenderPlacementResult = await lenderPlacementService.createLenderPlacement(placement, options);

      if (lenderPlacementResult) {
        const uploadedFileUrls = [];
        uploadedFileUrls.push(lenderPlacementResult.termSheet);
        await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
      }
    })
  );
  return res.status(httpStatus.CREATED).send({ results: 'Lender added to the deal' });
});

export const update = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user._id;
  const { lenderPlacementId } = req.params;
  const { user } = req;
  const termsheet = body.termSheet;
  const moveFileObj = {
    ...(body.termSheet && { termSheet: body.termSheet.url }),
  };
  body._id = lenderPlacementId;
  await moveFiles({ body, user, moveFileObj });
  const filter = {
    _id: lenderPlacementId,
  };
  if (body.termSheet) {
    const { fileName } = termsheet;
    body.termSheet = encodeUrl(body.termSheet);
    body.termSheet = { url: body.termSheet, fileName };
  }
  if (body.terms) {
    const futureFunding = body.terms.futureFunding ? body.terms.futureFunding : 0;
    body.terms.totalLoanAmount = body.terms.initialFunding + futureFunding;
  }

  const options = {
    new: true,
    populate: [
      { path: 'lendingInstitution' },
      { path: 'lenderContact' },
      { path: 'notes' },
      { path: 'lenderAllContacts' },
      { path: 'deal' },
    ],
  };
  const beforeLenderPlacementResult = await lenderPlacementService.getLenderPlacementById(lenderPlacementId);

  const oldStage = beforeLenderPlacementResult.stage;

  if (body.stage) {
    body.stageEnumWiseNumber = stageOfLenderPlacementWithNumber(body.stage);
    body.nextStep = body.nextStep ? body.nextStep : enumModel.EnumNextStepOfLenderPlacement[body.stage];
    body.timeLine = manageLenderPlacementStageTimeline(oldStage, body.stage, beforeLenderPlacementResult.timeLine);
  }
  if (oldStage !== EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Only Archive possible when status changed from Closed to Archive..');
  }
  if (oldStage === EnumStageOfLenderPlacement.CLOSED && body.stage === EnumStageOfLenderPlacement.ARCHIVE) {
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage: EnumStageOfLenderPlacement.ARCHIVE,
    });
  }
  const lenderPlacementResult = await lenderPlacementService.updateLenderPlacement(filter, body, options);
  const dealId = lenderPlacementResult.deal;
  if (lenderPlacementResult.stage === enumModel.EnumStageOfLenderPlacement.CLOSING) {
    const stage = enumModel.EnumStageOfDeal.CLOSING;
    await Deal.findByIdAndUpdate(dealId, {
      stage,
      orderOfStage: stageOfDealWithNumber(stage),
      timeLine: manageDealStageTimeline(lenderPlacementResult.deal.stage, stage, lenderPlacementResult.deal.timeLine),
      details: await detailsInDeal(stage, dealId),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${lenderPlacementResult.deal.dealName} moved into closing with ${lenderPlacementResult.lendingInstitution.lenderNameVisible}`,
      deal: dealId,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  }
  // tempS3
  if (lenderPlacementResult.termSheet) {
    const uploadedFileUrls = [];
    uploadedFileUrls.push(lenderPlacementResult.termSheet.url);
    await TempS3.updateMany({ url: { $in: uploadedFileUrls } }, { active: true });
  }
  // if termSheet added for first time than only we add activity logs and update lenderPlacement stage to termSheet Received
  if (!beforeLenderPlacementResult.termSheet && body.termSheet) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} posted a term sheet on ${lenderPlacementResult.deal.dealName}`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_SHEET_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }

  // if terms added for first time than only we add activity logs and update lenderPlacement stage to terms Received
  if (!beforeLenderPlacementResult.terms && body.terms) {
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${beforeLenderPlacementResult.lendingInstitution.lenderNameVisible} sent over terms`,
      deal: lenderPlacementResult.deal,
      lender: lenderPlacementResult.lendingInstitution,
      type: EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    await activityLogService.createActivityLog(createActivityLogBody);

    const stage = EnumStageOfLenderPlacement.TERMS_RECEIVED;
    await LenderPlacement.findByIdAndUpdate(lenderPlacementId, {
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
      timeLine: manageLenderPlacementStageTimeline(oldStage, stage, beforeLenderPlacementResult.timeLine),
      nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
    });
  }

  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const updateMany = catchAsync(async (req, res) => {
  const { body } = req;
  body.updatedBy = req.user;
  const { lenderPlacementIds } = req.body;
  const updateBody = req.body.update;
  const filter = {
    _id: { $in: lenderPlacementIds },
  };
  const options = { new: true };
  const lenderPlacementResult = await lenderPlacementService.updateManyLenderPlacement(filter, updateBody, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacementResult });
});

export const remove = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeByDealAndLendingInstitution = catchAsync(async (req, res) => {
  const { deal, lendingInstitution } = req.query;
  const filter = {
    deal,
    lendingInstitution,
  };
  const lenderPlacement = await lenderPlacementService.removeLenderPlacement(filter);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const sendDeal = catchAsync(async (req, res) => {
  const { lenderInstitute, deal, lenderPlacement } = req.body;
  const advisorName = req.user.name;
  const advisorEmail = req.user.email;
  const filterToFindContact = {
    lenderInstitute,
  };
  const filterToFindPlacement = {
    lendingInstitution: lenderInstitute,
  };
  const filterToFindDeal = {
    deal,
  };
  const lenderContact = await lenderPlacementService.sendDeal(filterToFindContact, filterToFindPlacement, filterToFindDeal);

  let lenderName;
  if (lenderContact.lenderPlacement.lendingInstitution) {
    lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
  }

  let totalLoanAmount = 0;
  const { docIds } = lenderContact;
  const createTemplates = [];

  if (!lenderContact.lenderPlacement.terms) {
    totalLoanAmount = 0;
  } else {
    totalLoanAmount = lenderContact.lenderPlacement.terms.totalLoanAmount;
    totalLoanAmount /= 1000000;
    totalLoanAmount = totalLoanAmount.toFixed(2);
  }

  if (lenderPlacement) {
    const contact = lenderContact.lenderContact.map((lc) => {
      return {
        sendTo: lc.email,
        name: lc.firstName,
      };
    });

    const staticEmailTemplateData = sendDealTemplate1Text();
    const templateData = await EmailTemplate.find({
      lenderPlacement,
      isFirstTime: true,
    });
    if (!templateData.length) {
      const defaultTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName,
        contact,
        subject: '547 Valley Road - $1.5m Acquisition Financing',
        dealDocument: docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: true,
        isEmailSent: false,
        totalLoanAmount,
        templateName: `defaultTemplate - ${lenderName}`,
      });
      const blankTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName,
        contact,
        subject: '',
        dealDocument: docIds,
        emailContent: '',
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: true,
        isEmailSent: false,
        isBlankTemplate: true,
        templateName: `blankTemplate - ${lenderName}`,
      });
      createTemplates.push(defaultTemplate, blankTemplate);
    }
  }
  return res.status(httpStatus.OK).send({ createTemplates });
});

export const getEmailTemplatesByLanderPlacementId = catchAsync(async (req, res) => {
  const { lenderPlacement } = req.params;
  const filter = {
    lenderPlacement,
  };

  const emailTemplate = await emailTemplateService.getEmailTemplateList(filter);
  return res.status(httpStatus.OK).send({ results: emailTemplate });
});

export const getTemplateByTemplateId = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter).populate('deal');
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id!');
  }
  return res.status(httpStatus.OK).send({ getEmailTemplate });
});

export const updateAndSaveInitialEmailContent = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;

  const filter = {
    _id: emailTemplateId,
  };
  const getEmailTemplate = await EmailTemplate.findOne(filter).lean();
  if (!getEmailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  if (req.body.templateName === getEmailTemplate.templateName) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'A template with the same name already exists..');
  }

  const body = {
    ...getEmailTemplate,
  };
  delete body._id;

  const emailContent = req.body.emailContent ? req.body.emailContent : body.emailContent;

  const updatedBody = {
    ...body,
    ...req.body,
    ...{ lenderPlacement: getEmailTemplate.lenderPlacement },
    ...{ isFirstTime: false },
    ...{
      /*
       * he (for “HTML entities”) is a robust HTML entity encoder/decoder written in JavaScript
       * */
      emailContent: he.decode(emailContent),
    },
  };

  if (updatedBody.emailAttachments) {
    const emailAttachments = updatedBody.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });
    delete updatedBody.emailAttachments;
    updatedBody.emailAttachments = emailAttachments;
  }
  if (updatedBody.sendTo) {
    const result = updatedBody.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (updatedBody.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = updatedBody.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }

          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);
          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      updatedBody.contact = data;
    } else {
      updatedBody.contact = result;
    }
    delete updatedBody.sendTo;
  }

  const templateData = await EmailTemplate.create(updatedBody);

  return res.status(httpStatus.OK).send({ templateData });
});

export const sendEmail = catchAsync(async (req, res) => {
  const { emailTemplateId } = req.params;
  const { sendToAdvisor } = req.body;
  const filter = {
    _id: emailTemplateId,
  };
  const getUser = await User.findOne({ _id: req.user._id });
  const { emailPresentingPostmark } = getUser;
  const emailTemplate = await EmailTemplate.findOne(filter).lean().populate('deal');

  if (!emailTemplate) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'no EmailTemplate found with this id..!!');
  }

  let getEmailTemplate;
  if (req.body.getEmailTemplate) {
    getEmailTemplate = req.body.getEmailTemplate;
    const result = getEmailTemplate.sendTo.map((item) => {
      return {
        sendTo: item,
      };
    });
    if (emailTemplate.contact) {
      // eslint-disable-next-line array-callback-return
      const data = await Promise.all(
        result.map(async (item) => {
          const getRecordFromContact = emailTemplate.contact.find((value) => item.sendTo === value.sendTo);
          if (getRecordFromContact) {
            return getRecordFromContact;
          }
          // eslint-disable-next-line no-shadow
          const filter = {
            email: item.sendTo,
          };
          const lenderContact = await lenderContactService.getOne(filter);

          if (!lenderContact) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'First, Add this Email in Lender Contact');
          }
          // eslint-disable-next-line no-param-reassign
          item.name = lenderContact.firstName;
          return item;
        })
      );

      getEmailTemplate.contact = data;
    } else {
      getEmailTemplate.contact = result;
    }
    delete getEmailTemplate.sendTo;
    if (getEmailTemplate.emailContent) {
      getEmailTemplate.emailContent = he.decode(getEmailTemplate.emailContent);
    }
  } else {
    getEmailTemplate = emailTemplate;
  }

  const placementId = getEmailTemplate.lenderPlacement;

  const dealId = emailTemplate.deal._id;

  const ccList = getEmailTemplate.ccList.map((item) => item);

  const bccList = getEmailTemplate.bccList.map((item) => item);

  const headers = [
    {
      Value: `${placementId}`,
    },
  ];

  const sendToIsEmpty = getEmailTemplate.contact.map((item) => item.sendTo);
  _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  if (sendToIsEmpty.length === 0) {
    return res.status(httpStatus.OK).send({ results: 'No email addresses to send to.' });
  }
  if (sendToAdvisor) {
    const isAdvisor = _.template(getEmailTemplate.emailContent)({
      userFirstName: req.user.firstName,
      totalLoanAmount: getEmailTemplate.totalLoanAmount,
      advisorName: req.user.firstName,
      advisorEmail: req.user.email,
    });
    const emailAttachments = getEmailTemplate.emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    });

    await emailService.sendEmail({
      to: req.user.email,
      subject: `TEST - ${getEmailTemplate.subject}`,
      ...(emailPresentingPostmark && { from: req.user.email }),
      text: isAdvisor,
      attachments: emailAttachments,
      isHtml: true,
      headers,
    });
    return res.status(httpStatus.OK).send({ results: 'Test-mail sent..' });
  }
  const getText = (userFirstName, totalLoanAmount, advisorName, advisorEmail) => {
    const data = _.template(getEmailTemplate.emailContent)({
      userFirstName,
      totalLoanAmount,
      advisorName,
      advisorEmail,
    });
    return data;
  };

  // todo : make function for this one, and make synchronize so we can handle error coming from that.
  await Promise.allSettled(
    getEmailTemplate.contact.map((item) => {
      return emailService.sendEmail({
        to: item.sendTo,
        cc: ccList,
        bcc: bccList,
        subject: getEmailTemplate.subject,
        ...(emailPresentingPostmark && { from: req.user.email }),
        text: getText(item.name, getEmailTemplate.totalLoanAmount, getEmailTemplate.advisorName, getEmailTemplate.from),
        // eslint-disable-next-line no-shadow
        attachments: getEmailTemplate.emailAttachments.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url ? item.url : item.path,
            fileType: item.fileType,
          };
        }),
        isHtml: true,
        headers,
      });
    })
  );

  const result = await LenderPlacement.findOne({ _id: placementId });

  if (result.isEmailSent === EnumOfEmailStatus.SEND_DEAL) {
    const stage = EnumStageOfLenderPlacement.SENT;
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: true,
      stage,
      stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
    });
  } else {
    await LenderPlacement.findByIdAndUpdate(placementId, {
      followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
      isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
      isEmailSentFirstTime: false,
    });
  }
  const stage = EnumStageOfDeal.OUT_IN_MARKET;
  await Deal.findByIdAndUpdate(dealId, {
    stage,
    orderOfStage: stageOfDealWithNumber(stage),
    $push: { timeLine: { stage, updatedAt: new Date() } },
    details: await detailsInDeal(stage, dealId),
  });
  const deal = await Deal.findById(dealId);
  const createActivityLogBody = {
    createdBy: req.user._id,
    updatedBy: req.user._id,
    update: `${deal.dealName} was sent out to lenders`,
    deal: dealId,
    type: EnumOfActivityType.ACTIVITY,
    user: config.activitySystemUser || 'system',
  };
  if (createActivityLogBody.update) {
    await activityLogService.createActivityLog(createActivityLogBody);
  }
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendDealV2 = catchAsync(async (req, res) => {
  const { deals } = req.body;
  const frontEndUrl = config.front.url || 'http://54.196.81.18';
  const admin = req.user;
  const { isFollowUp } = req.query;
  const { emailPresentingPostmark } = admin;
  const advisorEmail = admin.email;
  const promises = await deals.map(async (body) => {
    const { lenderInstitute, deal, lenderPlacement, followUpContent, lender } = body;
    const filterToFindContact = {
      lenderInstitute,
    };
    const filterToFindPlacement = {
      lendingInstitution: lenderInstitute,
      deal,
    };
    const filterToFindDeal = {
      deal,
    };
    const lenderContact = await lenderPlacementService.sendDeal(
      filterToFindContact,
      filterToFindPlacement,
      filterToFindDeal
    );
    const emailBodyValues = {
      dealSummaryLink: `${frontEndUrl}/dealDetail/${deal}?tab=presentation`,
      // TODO: conform & remove from here if not needed
      passLink: `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`,
      advisorName: admin.firstName,
      documents: [],
      executiveSummary: '',
    };
    if (lenderContact.lenderPlacement.lendingInstitution) {
      emailBodyValues.lenderName = lenderContact.lenderPlacement.lendingInstitution.lenderNameVisible;
    }
    let totalLoanAmount = 0;
    if (lenderContact.lenderPlacement && lenderContact.lenderPlacement.deal) {
      emailBodyValues.dealName = lenderContact.lenderPlacement.deal.dealName;
      // here loanAmount is coming as $100,000 (string) so we are converting that to number
      totalLoanAmount = lenderContact.lenderPlacement.deal.loanAmount.replace(/[$,]/g, '') * 1;
      // totalLoanAmount is converted into millions so if 1000000 then it should be 1
      totalLoanAmount /= 1000000;
      totalLoanAmount.toFixed(2);
      emailBodyValues.loanAmount = totalLoanAmount;
    }

    const dealSummaryDocs = [];
    if (lenderContact.lenderPlacement.deal.dealSummary && !isFollowUp) {
      if (
        lenderContact.lenderPlacement.deal.dealSummary.documents &&
        lenderContact.lenderPlacement.deal.dealSummary.documents.length
      ) {
        const documentsText = 'Please see attached for deal materials';
        emailBodyValues.documentsText = documentsText;
        dealSummaryDocs.push(...lenderContact.lenderPlacement.deal.dealSummary.documents);
      }
      if (lenderContact.lenderPlacement.deal.dealSummary.executiveSummary && !isFollowUp) {
        emailBodyValues.executiveSummary = lenderContact.lenderPlacement.deal.dealSummary.executiveSummary;
      }
    }

    const { docIds } = lenderContact;

    const lendersDetail = lenderContact.lenderContact.filter((lc) => lc._id.toString() === lender);
    const contact = lendersDetail.map((lc) => {
      return {
        sendTo: lc.email,
        name: lc.firstName,
        _id: lc._id,
      };
    });
    _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
    const staticEmailTemplateData = isFollowUp ? followUpEmailContent() : borrowerSendDealEmailContent();
    let emailTemplate;
    const filter = isFollowUp
      ? {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`,
              `borrowerFollowUpTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        }
      : {
          lenderPlacement,
          templateName: {
            $in: [
              `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
              `borrowerSendDealTemplate - ${emailBodyValues.lenderName}`,
            ],
          },
        };
    emailTemplate = await emailTemplateService.getOne(filter, { populate: 'deal' });
    // if already template not available then we are create
    if (!emailTemplate) {
      emailTemplate = await EmailTemplate.create({
        from: advisorEmail,
        advisorName: admin.firstName,
        contact,
        subject: `${emailBodyValues.dealName}-$${emailBodyValues.loanAmount}m Financing Request`,
        dealDocument: isFollowUp ? [] : docIds,
        emailContent: staticEmailTemplateData,
        lenderPlacement,
        deal,
        emailAttachments: [],
        isFirstTime: !isFollowUp,
        isEmailSent: false,
        totalLoanAmount,
        templateName: isFollowUp
          ? `advisorFollowUpTemplate - ${emailBodyValues.lenderName}`
          : `advisorSendDealTemplate - ${emailBodyValues.lenderName}`,
      });
    }
    const getEmailTemplate = emailTemplate;
    const placementId = getEmailTemplate.lenderPlacement;

    const ccList = getEmailTemplate.ccList.map((item) => item);

    const bccList = getEmailTemplate.bccList.map((item) => item);

    const headers = [
      {
        Value: `${placementId}`,
      },
    ];

    // todo : make function for this one, and make synchronize so we can handle error coming from that.
    // await Promise.allSettled(
    await asyncForEach(getEmailTemplate.contact, async (item) => {
      let dealSummaryLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary`;
      let passLink = `${frontEndUrl}/dealDetail/${deal}?tab=dealSummary&pass=true`;
      const user = await userService.getOne({ email: item.sendTo, role: enumModel.EnumRoleOfUser.LENDER });
      if (!user) {
        dealSummaryLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        passLink = `${frontEndUrl}/register?isRedirectedFromSendDeal=true&id=${item._id}`;
        await invitationService.createInvitation({
          deal,
          invitedBy: admin._id,
          inviteeEmail: item.sendTo,
          role: enumModel.EnumRoleOfUser.LENDER,
        });
      }
      return emailService.sendEmail({
        to: item.sendTo,
        cc: ccList,
        bcc: bccList,
        subject: getEmailTemplate.subject,
        ...(emailPresentingPostmark && { from: req.user.email }),
        text: getTextFromTemplate({
          lenderName: item.name,
          executiveSummary: emailBodyValues.executiveSummary,
          documents: emailBodyValues.documentsText,
          // dealSummaryLink: emailBodyValues.dealSummaryLink,
          dealSummaryLink,
          // passLink: emailBodyValues.passLink,
          passLink,
          advisorName: emailBodyValues.advisorName,
          emailTemplate: getEmailTemplate.emailContent,
          followUpContent: followUpContent || `following up, did you have any feedback on this deal.`,
        }),
        // eslint-disable-next-line no-shadow
        attachments: dealSummaryDocs.map((item) => {
          return {
            fileName: item.fileName,
            path: item.url,
            fileType: item.url.split('.').pop(),
          };
        }),
        isHtml: true,
        headers,
      });
    });
    // );

    const result = await lenderPlacementService.getOne({ _id: placementId });

    if (result.isEmailSent === enumModel.EnumOfEmailStatus.SEND_DEAL) {
      const stage = enumModel.EnumStageOfLenderPlacement.SENT;
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: true,
          stage,
          stageEnumWiseNumber: stageOfLenderPlacementWithNumber(stage),
          nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
          timeLine: manageLenderPlacementStageTimeline(result.stage, stage, result.timeLine),
        }
      );
    } else {
      await lenderPlacementService.updateLenderPlacement(
        { _id: placementId },
        {
          followOnDate: new Date(Date.now() + config.followUpTimeForSendEmail),
          isEmailSent: enumModel.EnumOfEmailStatus.EMAIL_SENT,
          isEmailSentFirstTime: false,
        }
      );
    }
    const stage = enumModel.EnumStageOfDeal.OUT_IN_MARKET;
    const dealData = await dealService.updateDeal(
      { _id: deal },
      {
        stage,
        orderOfStage: stageOfDealWithNumber(stage),
        timeLine: manageDealStageTimeline(
          lenderContact.lenderPlacement.deal.stage,
          stage,
          lenderContact.lenderPlacement.deal.timeLine
        ),
        nextStep: enumModel.EnumNextStepOfLenderPlacement[stage],
        details: await detailsInDeal(stage, deal),
      },
      { new: true }
    );
    const createActivityLogBody = {
      createdBy: req.user._id,
      updatedBy: req.user._id,
      update: `${dealData.dealName} was sent out to lenders`,
      deal,
      type: enumModel.EnumOfActivityType.ACTIVITY,
      user: config.activitySystemUser || 'system',
    };
    if (createActivityLogBody.update) {
      await activityLogService.createActivityLog(createActivityLogBody);
    }
  });
  await Promise.all(promises);
  return res.status(httpStatus.OK).send({ results: 'Email sent....' });
});

export const sendMessage = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const advisor = req.user;
  const { emailPresentingPostmark } = advisor;
  const { body } = req;
  const filter = {
    _id: lenderPlacementId,
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter);
  const lenderContact = await lenderContactService.getOne(
    {
      lenderInstitute: lenderPlacement.lendingInstitution,
    },
    { populate: 'lenderInstitute' }
  );
  const emailAttachments = body.documents ? body.documents : [];
  const headers = [
    {
      Value: `${lenderPlacementId}`,
    },
  ];
  // send email to lender in reply of send-deal mail
  const emailTemplate = await emailTemplateService.getOne({
    lenderPlacement: lenderPlacementId,
    templateName: `advisorSendDealTemplate - ${lenderContact.lenderInstitute.lenderNameVisible}`,
  });
  await emailService.sendEmail({
    to: lenderContact.email,
    subject: emailTemplate.subject,
    ...(emailPresentingPostmark && { from: req.user.email }),
    text: body.message,
    attachments: emailAttachments.map((item) => {
      return {
        fileName: item.fileName,
        path: item.url ? item.url : item.path,
        fileType: item.fileType,
      };
    }),
    isHtml: false,
    // Headers: [{ Name: 'In-Reply-To', Value: 'originalMessageId@example.com' }],
    headers,
  });
  await lenderPlacementService.updateLenderPlacement(
    { _id: lenderPlacementId },
    {
      $push: {
        messages: { sender: advisor.firstName, updatedAt: new Date(), message: body.message, documents: body.documents },
      },
    }
  );
  return res.status(httpStatus.OK).send({ results: 'Message sent...' });
});

export const getMessages = catchAsync(async (req, res) => {
  const { lenderPlacementId } = req.params;
  const filter = {
    _id: lenderPlacementId,
  };
  const options = {
    select: { messages: 1 },
  };
  const lenderPlacement = await lenderPlacementService.getOne(filter, options);
  return res.status(httpStatus.OK).send({ results: lenderPlacement });
});

export const removeDocument = catchAsync(async (req, res) => {
  const { lenderPlacementId, documentId } = req.params;
  const query = {
    _id: lenderPlacementId,
  };
  const updates = {
    $pull: {
      'messages.$[].documents': { _id: documentId }, // Remove the document with this _id from the documents array
    },
  };
  await lenderPlacementService.updateLenderPlacement(query, updates);
  return res.status(httpStatus.OK).send({ results: 'Document removed.' });
});

/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import ApiError from 'utils/ApiError';
import httpStatus from 'http-status';
import { Deal, Invitation, User } from 'models';
import mongoose from 'mongoose';
import _ from 'lodash';
import enumModel from '../models/enum.model';
import { emailService, notificationService, userService } from './index';
import config from '../config/config';

/**
 * Validates the list of involved users for a specific role in a given request body.
 *
 * @param {Object} body - The request body containing information about involved users.
 * @param {string} role - The role for which the involved users need to be validated.
 * @throws {ApiError} Throws a BAD_REQUEST error if any user for the specified role is not found.
 * @returns {Promise<void>} - Resolves if validation is successful.
 */
const validateInvolvedUsers = async (body, role) => {
  // Check if the involved users for the specified role exist in the body.
  if (body.involvedUsers && body.involvedUsers[role] && body.involvedUsers[role].length) {
    const users = await userService.getUserList({ _id: { $in: body.involvedUsers[role] } });
    // Check if the number of retrieved users matches the number of specified user IDs.
    if (users.length !== body.involvedUsers[role].length) {
      // Find the user IDs that were not found in the userService response.
      const usersNotFound = _.differenceBy(
        body.involvedUsers[role].map((userId) => userId.toString()),
        users.map((user) => user._id.toString())
      );
      throw new ApiError(httpStatus.BAD_REQUEST, `${role} not found for id ${usersNotFound.join(', ')}`);
    }
  }
};

export async function getDealById(id, options = {}) {
  const deal = await Deal.findById(id, options.projection, options);
  return deal;
}

export async function getOne(query, options = {}) {
  const deal = await Deal.findOne(query, options.projection, options).lean();
  return deal;
}

export async function getDealList(filter, options = {}) {
  const deal = await Deal.find(filter, options.projection, options);
  return deal;
}

export async function getDealListWithPagination(filter, options = {}) {
  const deal = await Deal.paginate(filter, options);
  return deal;
}

export async function createDeal(body) {
  const getUser = await userService.getOne({ _id: body.user });
  const { firstName: userName, sendEmailFrom: fromEmail, appPassword: pass } = getUser;

  await Promise.all([
    validateInvolvedUsers(body, 'advisors'),
    validateInvolvedUsers(body, 'lenders'),
    validateInvolvedUsers(body, 'borrowers'),
  ]);

  const dealId = mongoose.Types.ObjectId();
  const deal = { _id: dealId };
  if (body.dealMembers && body.dealMembers.length) {
    Object.assign(body.involvedUsers, { advisors: body.user });
    const existingUsers = await User.find({ email: { $in: body.dealMembers } });
    Object.assign(body.involvedUsers, { borrowers: existingUsers.map((item) => item._id) });
    if (existingUsers.length) {
      // In existing users we get the user document of the the emails we pass in the dealMembers if it exists in the system so in the below line we are checking now whether the role of the user is 'user' or not
      // If it is not user(borrower) then we'll throw the error as in the deal we can only add borrowers(user)
      if (existingUsers.some((user) => user.role !== enumModel.EnumRoleOfUser.USER)) {
        throw new ApiError(httpStatus.BAD_REQUEST, "Deal members email can be of borrower's only");
      }
      // userEmailNotExist ==> Here,we will get the emails that are not in our system.
      const userEmailNotExists = _.differenceBy(
        body.dealMembers,
        existingUsers.map((item) => item.email)
      );
      if (userEmailNotExists && userEmailNotExists.length) {
        throw new ApiError(httpStatus.BAD_REQUEST, `The borrowers : ${userEmailNotExists.join(', ')} doesn't exists`);
      }
      // Below flow is updated as per client's requirements ,so commented that part
      // if (userEmailNotExists.length) {
      //   await Promise.allSettled(
      //     userEmailNotExists.map(async (user) => {
      //       return emailService
      //         .sendInvitationEmail({
      //           fromEmail,
      //           pass,
      //           user,
      //           userName,
      //           dealName: body.dealName,
      //           isDealCreated: false,
      //           link: 'register',
      //         })
      //         .then()
      //         .catch();
      //     })
      //   );
      //
      //   userEmailNotExists.map(async (user) => {
      //     const notification = {
      //       createdBy: body.createdBy,
      //       updatedBy: body.createdBy,
      //       message: `${user} Requested to be added to ${body.dealName}`,
      //       deal,
      //     };
      //     await notificationService.createNotification(notification);
      //   });
      //
      //   await Invitation.insertMany(
      //     userEmailNotExists.map((nonExistingEmail) => ({
      //       deal: deal._id,
      //       invitedBy: body.user,
      //       inviteeEmail: nonExistingEmail,
      //       role: enumModel.EnumRoleOfUser.USER, // as while creating deal we can only add user/advisor to the deal
      //     }))
      //   );
      // }

      // need to send first name in the mail for existing users
      existingUsers.map(async (item) => {
        const { firstName, email: user } = item;
        return emailService.sendInvitationEmail({
          fromEmail,
          pass,
          user,
          userName,
          dealName: body.dealName,
          isDealCreated: false,
          link: 'login',
          firstName,
        });
      });

      existingUsers.map(async (user) => {
        const notification = {
          createdBy: body.createdBy,
          updatedBy: body.createdBy,
          message: `${user.email} Requested to be added to ${body.dealName}`,
          deal,
        };
        await notificationService.createNotification(notification);
      });

      // as our existingUsers is array we are using map on it. below line will help us to insert many document in our db at once, and we have passed the object in the map we have to enter in our db
      // so we will get deal id, the user from which we login or who is creating deal their id will go in invitedBy and in emailExists we get the whole document and we just want id of the person which we are inviting the deal so we did emailExists._id
      await Invitation.insertMany(
        existingUsers.map((emailExists) => ({
          deal: deal._id,
          status: 'accepted',
          invitedBy: body.user,
          invitee: emailExists._id,
          role: enumModel.EnumRoleOfUser.USER,
        }))
      );
    } else {
      throw new ApiError(httpStatus.BAD_REQUEST, `The borrowers : ${body.dealMembers.join(', ')} doesn't exists`);
    }
    // Below flow is updated as per client's requirements ,so commented that part
    // else {
    //   await Promise.allSettled(
    //     body.dealMembers.map(async (user) => {
    //       return emailService
    //         .sendInvitationEmail({
    //           fromEmail,
    //           pass,
    //           user,
    //           userName,
    //           dealName: body.dealName,
    //           isDealCreated: false,
    //           link: 'register',
    //         })
    //         .then()
    //         .catch();
    //     })
    //   );
    //
    //   body.dealMembers.map(async (user) => {
    //     const notification = {
    //       createdBy: body.createdBy,
    //       updatedBy: body.createdBy,
    //       message: `${user} Requested to be added to ${body.dealName}`,
    //       deal,
    //     };
    //     await notificationService.createNotification(notification);
    //   });
    //
    //   await Invitation.insertMany(
    //     body.dealMembers.map((nonExistingEmail) => ({
    //       deal: deal._id,
    //       invitedBy: body.user,
    //       inviteeEmail: nonExistingEmail,
    //       role: enumModel.EnumRoleOfUser.USER,
    //     }))
    //   );
    // }
  }

  const dealCreate = await Deal.create({ ...body, ...deal });

  const { defaultAdvisorToAddDeal } = config;
  await Promise.all(
    defaultAdvisorToAddDeal.map(async (item) => {
      const user = await User.findOne({ email: item });
      // eslint-disable-next-line no-shadow
      const body = {
        deal: dealCreate._id,
        email: [item],
      };
      const { role } = user;
      if (!dealCreate.involvedUsers.advisors.includes(user._id)) {
        // eslint-disable-next-line no-use-before-define
        await InviteToDeal(fromEmail, body, role, userName, dealCreate, pass);
      }
    })
  );
  return dealCreate;
}
export async function updateDeal(filter, body, options = {}) {
  await Promise.all([
    validateInvolvedUsers(body, 'advisors'),
    validateInvolvedUsers(body, 'lenders'),
    validateInvolvedUsers(body, 'borrowers'),
  ]);
  const deal = await Deal.findOneAndUpdate(filter, body, options);
  return deal;
}

export async function updateManyDeal(filter, body, options = {}) {
  const deal = await Deal.updateMany(filter, body, options);
  return deal;
}

export async function removeDeal(filter) {
  const deal = await Deal.findOneAndRemove(filter);
  return deal;
}

export async function removeManyDeal(filter) {
  const deal = await Deal.deleteMany(filter);
  return deal;
}

export async function InviteToDeal(fromEmail, body, role, userName, deal, pass) {
  const dealId = { _id: body.deal };
  const { email } = body;

  if (body.email && body.email.length) {
    const existingUsers = await User.find({ email: { $in: body.email } });
    // Not allowing non-existing advisor to get added in the deal
    if (role === enumModel.EnumRoleOfUser.ADVISOR) {
      // eslint-disable-next-line no-shadow
      const nonExistingUsers = body.email.filter((email) => !existingUsers.some((user) => user.email === email));
      if (nonExistingUsers.length > 0) {
        throw new ApiError(httpStatus.BAD_REQUEST, "This advisor doesn't exist in the system");
      }
    }
    if (existingUsers.length) {
      if (existingUsers.some((user) => user.role !== role)) {
        throw new ApiError(httpStatus.BAD_REQUEST, `You can only add ${role} to the deal`);
      }

      const roleChanged = {
        advisor: 'advisor',
        user: 'borrower',
      };

      const filter = {
        _id: dealId,
        [`involvedUsers.${roleChanged[role]}s`]: { $in: existingUsers.map((item) => item._id) },
      };
      const userAlreadyIncluded = await Deal.findOne(filter);
      if (userAlreadyIncluded) {
        throw new ApiError(httpStatus.BAD_REQUEST, `The ${role} is already part of the deal`);
      }
      const userEmailNotExists = _.differenceBy(
        body.email,
        existingUsers.map((item) => item.email)
      );
      if (userEmailNotExists && userEmailNotExists.length) {
        throw new ApiError(httpStatus.BAD_REQUEST, `The borrowers : ${userEmailNotExists.join(', ')} doesn't exists`);
      }
      await Deal.findByIdAndUpdate(dealId, {
        $addToSet: { [`involvedUsers.${roleChanged[role]}s`]: existingUsers.map((item) => item._id) },
      });
      // Below flow is updated as per client's requirements ,so commented that part
      // if (userEmailNotExists.length) {
      //   await Promise.allSettled(
      //     userEmailNotExists.map(async (user) => {
      //       return emailService
      //         .sendInvitationEmail({
      //           fromEmail,
      //           pass,
      //           user,
      //           userName,
      //           dealName: deal.dealName,
      //           isDealCreated: false,
      //           link: 'register',
      //         })
      //         .then()
      //         .catch();
      //     })
      //   );
      //
      //   userEmailNotExists.map(async (user) => {
      //     const notification = {
      //       createdBy: body.createdBy,
      //       updatedBy: body.createdBy,
      //       message: `${user} Requested to be added to ${deal.dealName}`,
      //       deal: dealId,
      //     };
      //     await notificationService.createNotification(notification);
      //   });
      //   await Invitation.insertMany(
      //     userEmailNotExists.map((nonExistingEmail) => ({
      //       deal: dealId,
      //       invitedBy: body.user,
      //       inviteeEmail: nonExistingEmail,
      //       role: body.role,
      //     }))
      //   );
      // }

      // need to send first name in the mail for existing users
      existingUsers.map(async (item) => {
        const { firstName, email: user } = item;
        return emailService.sendInvitationEmail({
          fromEmail,
          pass,
          user,
          userName,
          firstName,
          dealName: deal.dealName,
          isDealCreated: false,
          link: 'login',
        });
      });

      existingUsers.map(async (user) => {
        const notification = {
          createdBy: body.createdBy,
          updatedBy: body.createdBy,
          message: `${user.email} Requested to be added to ${deal.dealName}`,
          deal: dealId,
        };
        await notificationService.createNotification(notification);
      });

      await Invitation.insertMany(
        existingUsers.map((emailExists) => ({
          deal: dealId,
          status: 'accepted',
          invitedBy: body.user,
          invitee: emailExists._id,
          role: body.role,
        }))
      );
    } else {
      throw new ApiError(httpStatus.BAD_REQUEST, `The borrowers : ${email.join(', ')} doesn't exists`);
    }
    // Below flow is updated as per client's requirements ,so commented that part
    // else {
    //   await Promise.allSettled(
    //     email.map(async (user) => {
    //       return emailService
    //         .sendInvitationEmail({
    //           fromEmail,
    //           pass,
    //           user,
    //           userName,
    //           dealName: deal.dealName,
    //           isDealCreated: false,
    //           link: 'register',
    //         })
    //         .then()
    //         .catch();
    //     })
    //   );
    //
    //   email.map(async (user) => {
    //     const notification = {
    //       createdBy: body.createdBy,
    //       updatedBy: body.createdBy,
    //       message: `${user} Requested to be added to ${deal.dealName}`,
    //       deal: dealId,
    //     };
    //     await notificationService.createNotification(notification);
    //   });
    //
    //   await Invitation.insertMany(
    //     body.email.map((nonExistingEmail) => ({
    //       deal: dealId,
    //       invitedBy: body.user,
    //       inviteeEmail: nonExistingEmail,
    //       role: body.role,
    //     }))
    //   );
    // }
  }
}

/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import { Task } from 'models';
import mongoose from 'mongoose';

export async function getTaskById(id, options = {}) {
  const task = await Task.findById(id, options.projection, options);
  return task;
}

export async function getOne(query, options = {}) {
  const task = await Task.findOne(query, options.projection, options);
  return task;
}

export async function getTaskList(filter, options = {}) {
  const task = await Task.find(filter, options.projection, options);
  return task;
}

export async function getTaskListWithPagination(filter, options = {}) {
  const task = await Task.paginate(filter, options);
  return task;
}

export async function getTaskListWithPaginationBasedOnAskingPary(filter, options = {}, order) {
  const id = filter.deal;
  const objectId = mongoose.Types.ObjectId(id); // Converting the 'deal' field to ObjectId
  const { limit, page } = options;
  const task = await Task.aggregate([
    {
      $match: {
        deal: objectId, // Matching the 'deal' field with the ObjectId
      },
    },
    {
      $lookup: {
        from: 'users',
        localField: 'user',
        foreignField: '_id',
        as: 'user',
      },
    },
    {
      $lookup: {
        from: 'LendingInstitution',
        localField: 'askingPartyInstitute',
        foreignField: '_id',
        as: 'askingPartyInstitute',
      },
    },
    {
      $lookup: {
        from: 'User',
        localField: 'askingPartyAdvisor',
        foreignField: '_id',
        as: 'askingPartyAdvisor',
      },
    },
    {
      $addFields: {
        askingParty: {
          $cond: {
            if: { $gt: [{ $size: '$askingPartyInstitute' }, 0] }, // Checking if askingPartyInstitute array is not empty
            then: {
              $arrayElemAt: ['$askingPartyInstitute.lenderNameVisible', 0], // Getting the first element of lenderNameVisible array
            },
            else: {
              $concat: [
                { $arrayElemAt: ['$askingPartyAdvisor.firstName', 0] }, // Getting the first name of askingPartyAdvisor
                ' ',
                { $arrayElemAt: ['$askingPartyAdvisor.lastName', 0] }, // Getting the last name of askingPartyAdvisor
              ],
            },
          },
        },
      },
    },
    {
      $sort: { askingParty: parseInt(order, 10) }, // Sorting the documents based on askingParty field and order
    },
    {
      $group: {
        _id: null,
        results: { $push: '$$ROOT' }, // Grouping all documents into the results array
        totalCount: { $sum: 1 }, // Counting the total number of documents
      },
    },
    {
      $project: {
        results: '$results',
        totalResults: '$totalCount',
        limit: { $literal: limit },
        totalPages: { $ceil: { $divide: ['$totalCount', limit] } }, // Calculating the total number of pages based on limit
        page: { $literal: page },
        pagingCounter: { $literal: page * limit }, // Calculating the paging counter
        hasPrevPage: { $gt: [page, 1] }, // Checking if there is a previous page
        hasNextPage: { $lt: [page, { $ceil: { $divide: ['$totalCount', limit] } }] }, // Checking if there is a next page
        prevPage: { $cond: { if: { $gt: [page, 1] }, then: { $subtract: [page, 1] }, else: { $literal: null } } }, // Calculating the previous page number
        nextPage: {
          $cond: {
            if: { $lt: [page, { $ceil: { $divide: ['$totalCount', limit] } }] }, // Calculating the next page number
            then: { $add: [page, 1] },
            else: { $literal: null },
          },
        },
      },
    },
    {
      $skip: (page - 1) * limit, // Skipping documents based on pagination
    },
    {
      $limit: limit, // Limiting the number of documents in the result
    },
  ]);
  return task[0]; // Returning the first element of the task array
}

export async function createTask(body = {}) {
  const task = await Task.create(body);
  return task;
}

export async function updateTask(filter, body, options = {}) {
  const task = await Task.findOneAndUpdate(filter, body, options);
  return task;
}

export async function updateManyTask(filter, body, options = {}) {
  const task = await Task.updateMany(filter, body, options);
  return task;
}

export async function removeTask(filter) {
  const task = await Task.findOneAndRemove(filter);
  return task;
}

export async function removeManyTask(filter) {
  const task = await Task.deleteMany(filter);
  return task;
}

/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * Only fields name will be overwritten, if the field name will be changed.
 */
import { Sponsor } from 'models';
import { EnumRoleOfUser } from '../models/enum.model';
import { checkForExistingUser } from './user.service';
import { userService } from './index';

export async function getSponsorById(id, options = {}) {
  const sponsor = await Sponsor.findById(id, options.projection, options);
  return sponsor;
}

export async function getOne(query, options = {}) {
  const sponsor = await Sponsor.findOne(query, options.projection, options);
  return sponsor;
}

export async function getSponsorList(filter, options = {}) {
  const sponsor = await Sponsor.find(filter, options.projection, options);
  return sponsor;
}

export async function getSponsorListWithPagination(filter, options = {}) {
  const sponsor = await Sponsor.paginate(filter, options);
  return sponsor;
}

export async function createSponsor(body) {
  if (body.borrowersEmails && body.borrowersEmails.length) {
    const borrowers = await checkForExistingUser(body.borrowersEmails, EnumRoleOfUser.USER);
    Object.assign(body, { borrowers: borrowers.map((user) => user._id) });
  }
  const sponsor = await Sponsor.create(body);
  return sponsor;
}

export async function updateSponsor(filter, body, options = {}) {
  if (body.borrowersEmails && body.borrowersEmails.length) {
    const borrowers = await checkForExistingUser(body.borrowersEmails, EnumRoleOfUser.USER);
    Object.assign(body, { borrowers: borrowers.map((user) => user._id) });
  }
  // Verify whether the borrower emails have been modified.
  // Locate the associated sponsor and compare their list of borrower emails.
  // If the borrower emails have changed, identify the removed borrowers, and eliminate the sponsor's association from their records
  const sponsor = await getOne(filter);
  if (sponsor && sponsor.borrowersEmails !== body.borrowersEmails) {
    const removedBorrower = sponsor.borrowersEmails.filter((item) => !body.borrowersEmails.includes(item));
    if (removedBorrower && removedBorrower.length) {
      await userService.updateUser({ email: { $in: removedBorrower } }, { $pull: { sponsor: sponsor._id } });
    }
  }
  const updatedSponsor = await Sponsor.findOneAndUpdate(filter, body, options);
  return updatedSponsor;
}

export async function updateManySponsor(filter, body, options = {}) {
  const sponsor = await Sponsor.updateMany(filter, body, options);
  return sponsor;
}

export async function removeSponsor(filter) {
  const sponsor = await Sponsor.findOneAndRemove(filter);
  return sponsor;
}

export async function removeManySponsor(filter) {
  const sponsor = await Sponsor.deleteMany(filter);
  return sponsor;
}

export async function aggregateSponsor(query) {
  const sponsor = await Sponsor.aggregate(query);
  return sponsor;
}

export async function aggregateSponsorWithPagination(query, options = {}) {
  const aggregate = Sponsor.aggregate();
  // eslint-disable-next-line array-callback-return
  query.map((obj) => {
    aggregate._pipeline.push(obj);
  });
  const sponsor = await Sponsor.aggregatePaginate(aggregate, options);
  return sponsor;
}

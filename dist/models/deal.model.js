"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _mongoose = _interopRequireWildcard(require("mongoose"));
var _mongoosePaginateV = _interopRequireDefault(require("mongoose-paginate-v2"));
var _enum = _interopRequireDefault(require("./enum.model"));
var _plugins = require("./plugins");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 * If you want to add the new fields to your schema then go to the app.appinvento.io,
 * select your project then select model and click on + icon to add new fields.
 * For more checkout the docs at "docs.appinvento.io/product-guides/create-a-new-collection-field"
 */

/**
 * This file is generated by Appinvento, also it can be overwritten by Appinvento.
 */
var InvolvedUserSchema = new _mongoose["default"].Schema({
  /**
   *ObjecIds from User collection in the respective section
   * */
  lenders: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  },
  /**
   *ObjecIds from User collection in the respective section
   * */
  borrowers: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  },
  /**
   *ObjecIds from User collection in the respective section
   * */
  advisors: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  }
});
var pointSchema = new _mongoose["default"].Schema({
  type: {
    type: String,
    "enum": ['Point'],
    required: true
  },
  coordinates: {
    type: [Number],
    required: true
  }
});
var TimeLineSchema = new _mongoose["default"].Schema({
  stage: {
    type: String,
    "enum": Object.values(_enum["default"].EnumStageOfDeal)
  },
  updatedAt: {
    type: Date,
    "default": new Date()
  }
});
var DealSchema = new _mongoose["default"].Schema({
  /**
   * created By
   * */
  createdBy: {
    type: _mongoose["default"].Schema.Types.ObjectId,
    ref: 'User'
  },
  /**
   * updated By
   * */
  updatedBy: {
    type: _mongoose["default"].Schema.Types.ObjectId,
    ref: 'User'
  },
  /**
   * Name/Title of property on which deal need to be created
   * */
  dealName: {
    type: String,
    required: true
  },
  stage: {
    type: String,
    "enum": Object.values(_enum["default"].EnumStageOfDeal),
    "default": _enum["default"].EnumStageOfDeal.NEW
  },
  /**
   * Address of the property stored as free text
   * */
  address: {
    type: String,
    required: true,
    maxLength: 100
  },
  /**
   * city name
   * */
  city: {
    type: String,
    required: true,
    maxLength: 30
  },
  /**
   * state name
   * */
  state: {
    type: String,
    "enum": Object.values(_enum["default"].EnumStatesOfDeal),
    required: true
  },
  /**
   * zip code
   * */
  zipcode: {
    type: String,
    required: true,
    match: /^[0-9]{5}$/ // Regular expression to ensure it's 5 digits
  },
  /**
   * map co-ordinates to be stored as the exact location
   * */
  mapLocation: pointSchema,
  /**
   * hashmap of users involved in the deal. Collection of user-ids (ObjecIds from User collection) in the respective section
   * */
  involvedUsers: {
    type: InvolvedUserSchema,
    required: true
  },
  /**
   * list of user ids involved (lender) in the deal
   * */
  involvedUsersLender: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  },
  /**
   * list of user ids involved (borrower) in the deal
   * */
  involvedUsersBorrower: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  },
  /**
   * list of user ids involved (advisor) in the deal
   * */
  involvedUsersAdvisor: {
    type: [_mongoose["default"].Schema.Types.ObjectId],
    ref: 'User'
  },
  /**
   * Property Type
   * */
  assetType: {
    type: String,
    "enum": Object.values(_enum["default"].EnumAssetTypeOfDeal),
    required: true
  },
  /**
   * Loan amount to be requested. The assumption amount is in USD
   * */
  loanAmount: {
    type: String,
    required: true
  },
  /**
   * Purpose of the loan
   * */
  loanPurpose: {
    type: String,
    "enum": Object.values(_enum["default"].EnumLoanPurposeOfDeal),
    required: true
  },
  /**
   * Type of loan
   * */
  loanType: {
    type: String,
    "enum": Object.values(_enum["default"].EnumLoanTypeOfDeal)
  },
  /**
   * User creating the deal
   * */
  user: {
    type: _mongoose["default"].Schema.Types.ObjectId,
    ref: 'User'
  },
  orderOfStage: {
    type: Number,
    min: 0,
    max: _enum["default"].EnumStageOfDeal.length,
    "default": 5
  },
  squareFootage: {
    type: String
  },
  unitCount: {
    type: Number
  },
  occupancy: {
    type: String
  },
  details: {
    type: String,
    "default": 'Waiting on initial information needed from borrower'
  },
  dealSummary: {
    type: _mongoose["default"].Schema.Types.ObjectId,
    ref: 'DealSummary'
  },
  timeLine: {
    type: [TimeLineSchema],
    "default": [{
      stage: _enum["default"].EnumStageOfDeal.NEW,
      updatedAt: new Date()
    }]
  },
  loanInformation: [{
    key: {
      type: String
    },
    value: {
      type: _mongoose.Schema.Types.Mixed
    },
    type: {
      type: String,
      "enum": Object.values(_enum["default"].EnumOfTypeOfValue)
    }
  }],
  sponsor: {
    type: _mongoose["default"].Schema.Types.ObjectId,
    ref: 'Sponsor'
  }
}, {
  timestamps: {
    createdAt: true,
    updatedAt: true
  },
  autoCreate: true
});
DealSchema.virtual('notes', {
  ref: 'DealNotes',
  localField: '_id',
  foreignField: 'deal',
  justOne: false
});
DealSchema.virtual('documents', {
  ref: 'DealDocument',
  localField: '_id',
  foreignField: 'deal',
  justOne: false
});
DealSchema.virtual('task', {
  ref: 'Task',
  localField: '_id',
  foreignField: 'deal',
  justOne: false
});

// Lender now will only have 2 fields the date at which the deal received and the stage of the placement
DealSchema.virtual('lenderPlacement', {
  ref: 'LenderPlacement',
  localField: '_id',
  foreignField: 'deal',
  justOne: false
});

// DealSchema.virtual('outstandingTaskCount', {
//   ref: 'Task',
//   localField: '_id',
//   foreignField: 'deal',
//   count: true,
//   match: { taskAnswer: { $exists: false } },
// });

DealSchema.virtual('outstandingTaskCount', {
  ref: 'Task',
  localField: '_id',
  foreignField: 'deal',
  count: true,
  match: {
    $expr: {
      $or: [{
        $eq: ['$taskAnswer', []]
      },
      // Check if taskAnswer is an empty array
      {
        $not: {
          $isArray: '$taskAnswer'
        }
      } // Check if taskAnswer is not an array or non-existent
      ]
    }
  }
});
DealSchema.plugin(_plugins.toJSON);
DealSchema.plugin(_mongoosePaginateV["default"]);
DealSchema.plugin(_plugins.softDelete, {
  isSoftDeleteAddon: true,
  overrideMethods: 'all',
  deleted: 'isDeleted',
  deletedBy: 'deletedBy',
  deletedAt: 'deletedAt'
});
var DealModel = _mongoose["default"].models.Deal || _mongoose["default"].model('Deal', DealSchema, 'Deal');
module.exports = DealModel;